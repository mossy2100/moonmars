<?php

function moonmars_items_menu() {
  $items['ajax/item/update'] = array(
    'page callback'    => 'moonmars_items_ajax_update',
    'access callback'  => 'node_access',
    'access arguments' => array(
      'update',
      1
    ),
    'type'             => MENU_CALLBACK,
  );

  // @todo For deleting items we need to use the same permissions as for edit - this is different from the usual
  // delete item permissions, which is only available to users with the 'administer items' permission.
  $items['ajax/item/delete'] = array(
    'page callback'    => 'moonmars_items_ajax_delete',
    'access arguments' => array('administer items'),
    'type'             => MENU_CALLBACK,
  );

  $items['ajax/item/rate'] = array(
    'page callback'    => 'moonmars_items_ajax_rate',
    'access callback'  => 'node_access',
    'access arguments' => array(
      'update',
      1
    ),
    'type'             => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Gets a title from the item text, max 100 characters.
 *
 * @param stdClass $node
 * @return string
 */
function moonmars_items_auto_nodetitle(stdClass $node) {
  $text = $node->field_item_text[LANGUAGE_NONE][0]['value'];
  return (strlen($text) <= 100) ? $text : (substr($text, 0, 97) . '...');
}

/**
 * Check if a user is directly or indirectly subscribed to an item.
 *
 * @param $nid
 * @param $uid
 */
//function moonmars_items_member_subscribed($nid, $uid) {
//
//}

/**
 * Create the form for posting new items in group channels.
 *
 * @todo Make this more generic so it can be used for user and event channels as well.
 *
 * @return array
 */
//function moonmars_items_form() {
//  $group_nid = arg(1);
//
//
//
////  $form = drupal_get_form('node_form_item');
//  $form['new-item'] = array(
//    '#type' => 'textarea',
//    '#title' => t('Share something:'),
//    '#resizable' => FALSE,
//    '#value' => '',
//    '#rows' => 2,
//  );
//  $form['new-item-link'] = array(
//    '#type' => 'textfield',
//    '#title' => t('Link:'),
//    '#value' => '',
//  );
//  $form['new-item-image'] = array(
//    '#type' => 'file',
//    '#title' => t('File:'),
//    '#value' => '',
//  );
//  $form['group-nid'] = array(
//    '#type' => 'hidden',
//    '#default_value' => $group_nid,
//  );
//  $form['post-button'] = array(
//    '#markup' => "<button id='post-button'>Post</button>",
//  );
//  return $form;
//}

function moonmars_items_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'item_node_form' && moonmars_groups_is_group_page()) {
    // Hide a bunch of shit we don't want to see:
    unset($form['title']);
    unset($form['field_score']);
    unset($form['additional_settings']);
    unset($form['revision_information']);
    unset($form['author']);
    unset($form['comment_settings']);
    unset($form['options']);
    unset($form['field_item_type'][LANGUAGE_NONE]['#title']);
    unset($form['field_item_text'][LANGUAGE_NONE][0]['value']['#title']);
    unset($form['field_item_link'][LANGUAGE_NONE][0]['#title']);
    unset($form['field_item_file'][LANGUAGE_NONE][0]['#title']);

//    dbg($form['field_item_type']);

    // Change the button label:
    $form['actions']['submit']['#value'] = t('Post');

    // Make the textarea non-resizable and only 2 rows high. We will use the autoresize() plugin on the client.
    $form['field_item_text'][LANGUAGE_NONE][0]['value']['#resizable'] = FALSE;
    $form['field_item_text'][LANGUAGE_NONE][0]['value']['#rows'] = 2;

    // If this is a group channel, put the group nid in a hidden field so we can access it in the submit handler.
    if (alias_arg(0) == 'group') {
      $group_nid = (int) arg(1);
      if ($group_nid) {
        $form['group_nid'] = array(
          '#type'          => 'hidden',
          '#default_value' => $group_nid,
        );
      }
    }

    // Add an afterbuild handler so we can remove the submit buttons added in file_managed_file_process().
    $form['#after_build'][] = 'moonmars_items_form_after_build';

    // Add a submit handler.
    $form['#submit'][] = 'moonmars_items_form_submit';
  }
}

/**
 * After build handler for add new item form on group channel.
 *
 * @param array $form
 * @return array
 */
function moonmars_items_form_after_build($form) {
//  dpm($form);

  // Remove the file field's submit buttons from the form:
  unset($form['field_item_file'][LANGUAGE_NONE][0]['upload_button']);
  unset($form['field_item_file'][LANGUAGE_NONE][0]['remove_button']);

  return $form;
}

/**
 * Implement hook_node_insert().
 */
function moonmars_items_node_insert($node) {
  if ($node->type == 'item') {
    $item = $node;

    // Gather all the endpoint entities into one array
    if (moonmars_groups_is_group_page()) {
      $group_nid = arg(1);
      $group = node_load($group_nid);
      if ($group && $group->type == 'group') {
        $end_points = array(
          array(
            'entity_label' => $item->title,
            'entity_type'  => 'node',
            'entity_id'    => $item->nid
          ),
          array(
            'entity_label' => $group->title,
            'entity_type'  => 'node',
            'entity_id'    => $group_nid,
          ),
        );

        $type = 'is_post_for';
        $relation = relation_create($type, $end_points);
//        entity_form_submit_build_entity('relation', $relation, $form['relation_options'], $form_state);
        relation_save($relation);

        // Reload the group page:
        drupal_goto(drupal_get_path_alias('node/' . $group_nid));
      }
    }
  }
}

/**
 * Submit handler for add new item form.
 *
 * @param array $form
 * @param array $form_state
 */
function moonmars_items_form_submit($form, &$form_state) {
  // If the item is a file, copy the entered text to the file description:
  if ($form_state['values']['field_item_file'][LANGUAGE_NONE][0]['fid']) {
    $form_state['values']['field_item_file'][LANGUAGE_NONE][0]['description'] = $form_state['values']['field_item_file'][LANGUAGE_NONE][0]['value'];
  }
}

/**
 * Create or update an item via AJAX.
 *
 * @return string
 */
function moonmars_items_ajax_update() {
  // Get the request parameters. Support either GET or POST here, so we can use POST from the form but test using the query string.
  $item_nid = (int) $_REQUEST['item_nid'];
  $group_nid = (int) $_REQUEST['group_nid'];
  $text = trim($_REQUEST['text']);
  global $user;

  $mode = $item_nid ? 'edit' : 'create';

  // Check we have all the necessary params:
  if (!$group_nid || !$text || !$user || !$user->uid) {
    // Create the data array:
    $data = array(
      'result'    => FALSE,
      'item_nid'  => $item_nid,
      'group_nid' => $group_nid,
      'text'      => $text,
      'mode'      => $mode,
    );
    // Encode and send:
    echo json_encode($data);
    return;
  }

  if ($item_nid) {
    // Load the item:
    $item = node_load($item_nid);
  }
  else {
    // Create a new item:
    $item = entity_create('node', array('type' => 'item'));
    $item->uid = $user->uid;
    $item->status = 1;
  }

  // Update the item text:
  $item->field_item_text[LANGUAGE_NONE][0]['value'] = $text;

  // Save the item:
  entity_save('node', $item);

//  $render_array = node_view($item);

  // Theme the item:
  $html = theme('node',
    array(
         'elements' => array(
           '#node'    => $item,
         ),
         //      'content'  => $item->content
    )
  );

  // Create the data array:
  $data = array(
    'result'    => TRUE,
    'item_nid'  => $item->nid,
    'group_nid' => $group_nid,
    'mode'      => $mode,
    'text'      => $text,
    'html'      => $html,
  );

  // Encode and send:
  echo json_encode($data);
}

/**
 * Checks if an item is a post for a channel node (e.g. group, event, project).
 *
 * @param int $item_nid
 * @param int $channel_nid
 */
function moonmars_items_is_post_for($item_nid, $channel_nid) {
  // Get all is_post_for relations starting at $item_nid:
  $q = db_select('field_data_endpoints', 'fde')
    ->fields('fde', array('entity_id'))
    ->condition('bundle', 'is_post_for')
    ->condition('endpoints_entity_type', 'node')
    ->condition('endpoints_entity_id', $item_nid)
    ->condition('endpoints_r_index', 0);

//  dpm_query($q);

  $rs = $q->execute();
  foreach ($rs as $rec) {
//    dpm($rec);

    // See if there's a row with the same relation entity_id and endpoint at the channel node:
    $q2 = db_select('field_data_endpoints', 'fde')
      ->fields('fde', array('entity_id'))
      ->condition('bundle', 'is_post_for')
      ->condition('entity_id', $rec->entity_id)
      ->condition('endpoints_entity_type', 'node')
      ->condition('endpoints_entity_id', $channel_nid)
      ->condition('endpoints_r_index', 1);
    $rs2 = $q2->execute();
    foreach ($rs2 as $rec2) {
//      dpm($rec2);
    }

    if ($rs2->rowCount()) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * AJAX callback for rating items.
 */
function moonmars_items_ajax_rate() {
  $item_nid = (int) $_REQUEST['item_nid'];
  $rating = $_REQUEST['warning'];
  global $user;

  // Load the item:
  $item = node_load($item_nid);

  $rating_scores = moonmars_ratings_scores();

  // Check we have all the necessary params:
  if (!$item || !array_key_exists($rating, $rating_scores) || !$user || !$user->uid) {
    // Create the data array:
    $data = array(
      'result'    => FALSE,
      'item_nid'  => $item_nid,
      'rating'    => $rating,
    );
    // Encode and send:
    echo json_encode($data);
    return;
  }

  // Get the current score for the item:
  $score = (int) $item->field_score[LANGUAGE_NONE][0]['value'];

  // Check if the user already rated this:
  $rel_type = 'rated';
  $rel = moonmars_relationships_get_relationship($rel_type, 'user', $user->uid, 'node', $item_nid);
  if ($rel) {
    dbg($rel);

    // Subtract the points for the previous rating:
    $old_rating_score = $rel->field_rating[LANGUAGE_NONE][0]['value'] * $rel->field_multiplier[LANGUAGE_NONE][0]['value'];
    $score -= $old_rating_score;

    // Remove the old rating relationship:
    relation_delete($rel->rid);
  }

  // Create the rating:
  $end_points = array(
    array(
      'entity_label' => $user->name,
      'entity_type'  => 'user',
      'entity_id'    => $user->uid
    ),
    array(
      'entity_label' => $item->title,
      'entity_type'  => 'node',
      'entity_id'    => $item_nid,
    ),
  );
  $relation = relation_create($rel_type, $end_points);
  relation_save($relation);

  // Add the points for the new rating:
  $new_rating_score = $rating_scores[$rating] * moonmars_members_get_level_num($user);
  $score += $new_rating_score;

  // Update the item's score:
  $item->field_score[LANGUAGE_NONE][0]['value'] = $score;
  node_save($item);

  // Create the data array:
  $data = array(
    'result'    => TRUE,
    'item_nid'  => $item_nid,
    'rating'    => $rating,
    'score'     => $score,
  );
  // Encode and send:
  echo json_encode($data);
  return;
}
