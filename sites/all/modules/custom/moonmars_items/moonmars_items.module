<?php

function moonmars_items_menu() {
  $items['ajax/item/edit'] = array(
    'page callback'    => 'moonmars_items_ajax_edit',
    'access callback'  => 'user_is_logged_in',
    'type'             => MENU_CALLBACK,
  );
  $items['ajax/item/delete'] = array(
    'page callback'    => 'moonmars_items_ajax_delete',
    'access callback'  => 'user_is_logged_in',
    'type'             => MENU_CALLBACK,
  );
  $items['ajax/item/remove'] = array(
    'page callback'    => 'moonmars_items_ajax_remove',
    'access callback'  => 'user_is_logged_in',
    'type'             => MENU_CALLBACK,
  );

//  $items['ajax/item/rate'] = array(
//    'page callback'    => 'moonmars_items_ajax_rate',
//    'access callback'  => 'node_access',
//    'access arguments' => array(
//      'update',
//      1
//    ),
//    'type'             => MENU_CALLBACK,
//  );

  return $items;
}

/**
 * Create the form for posting new items in group channels.
 *
 * @todo Make this more generic so it can be used for user and event channels as well.
 *
 * @return array
 */
//function moonmars_items_form() {
//  $group_nid = arg(1);
//
//
//
////  $form = drupal_get_form('node_form_item');
//  $form['new-item'] = array(
//    '#type' => 'textarea',
//    '#title' => t('Share something:'),
//    '#resizable' => FALSE,
//    '#value' => '',
//    '#rows' => 2,
//  );
//  $form['new-item-link'] = array(
//    '#type' => 'textfield',
//    '#title' => t('Link:'),
//    '#value' => '',
//  );
//  $form['new-item-image'] = array(
//    '#type' => 'file',
//    '#title' => t('File:'),
//    '#value' => '',
//  );
//  $form['group-nid'] = array(
//    '#type' => 'hidden',
//    '#default_value' => $group_nid,
//  );
//  $form['post-button'] = array(
//    '#markup' => "<button id='post-button'>Post</button>",
//  );
//  return $form;
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Forms stuff

/**
 * Implements hook_form_alter().
 */
function moonmars_items_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'item_node_form' && isset($GLOBALS['channel_nid']) && $GLOBALS['channel_nid']) {

    $entity_type = arg(0);
    $entity_id = (int) arg(1);

    // Set the title:
    switch ($entity_type) {
      case 'user':
        $account = user_load($entity_id);
        drupal_set_title('Member: ' . $account->name);
        break;

      case 'node':
        $node = node_load($entity_id);
        drupal_set_title(ucfirst($node->type) . ': ' . $node->title);
        break;
    }

    // Hide stuff we don't want to see:
    unset($form['title']);
    unset($form['field_score']);
    unset($form['field_item_system']);
    unset($form['additional_settings']);
    unset($form['revision_information']);
    unset($form['author']);
    unset($form['comment_settings']);
    unset($form['options']);
    unset($form['field_item_type'][LANGUAGE_NONE]['#title']);
    unset($form['field_item_text'][LANGUAGE_NONE][0]['value']['#title']);
    unset($form['field_item_link'][LANGUAGE_NONE][0]['#title']);
    unset($form['field_item_image'][LANGUAGE_NONE][0]['#title']);
    unset($form['field_item_video'][LANGUAGE_NONE][0]['fid']['#title']);
    unset($form['field_item_document'][LANGUAGE_NONE][0]['#title']);

    // Change the button label:
    $form['actions']['submit']['#value'] = t('Post');

    // Make the textarea non-resizable and only 2 rows high. We will use the autoresize() plugin on the client. When it's working.
    $form['field_item_text']['#wysiwyg'] = FALSE;
    $form['field_item_text'][LANGUAGE_NONE][0]['value']['#resizable'] = FALSE;
    $form['field_item_text'][LANGUAGE_NONE][0]['value']['#rows'] = 2;

    // Add a hidden field to carry the channel nid:
    $form['channel_nid'] = array(
      '#type' => 'hidden',
      '#value' => $GLOBALS['channel_nid'],
    );

    // Validation handler.
    $form['actions']['submit']['#validate'][] = 'moonmars_items_form_validate';

    // Submit handler.
    $form['actions']['submit']['#submit'][] = 'moonmars_items_form_submit';
  }
}

/**
 * Validation handler for add new item form.
 */
function moonmars_items_form_validate($form, &$form_state) {
  dpm($form_state['values']);
}

/**
 * Submit handler for add new item form.
 */
function moonmars_items_form_submit($form, &$form_state) {
  if (isset($form_state['values']['channel_nid'])) {
    $GLOBALS['channel_nid'] = $form_state['values']['channel_nid'];

    // Redirect back to the entity page:
    $channel = Channel::create($GLOBALS['channel_nid']);
    $form_state['redirect'] = $channel->parentEntity()->alias();
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Node hooks.

/**
 * Implement hook_node_presave().
 */
function moonmars_items_node_presave($node) {
  if ($node->type == 'item') {
    // Get the item text:
    $text = $node->field_item_text[LANGUAGE_NONE][0]['value'];

    // If the item is a image, copy the entered text to the image title:
    if (isset($node->field_item_image[LANGUAGE_NONE][0]['fid']) && $node->field_item_image[LANGUAGE_NONE][0]['fid']) {
      $node->field_item_image[LANGUAGE_NONE][0]['title'] = $text;
    }
    
    // If the item is a document, copy the entered text to the document description:
    if (isset($node->field_item_document[LANGUAGE_NONE][0]['fid']) && $node->field_item_document[LANGUAGE_NONE][0]['fid']) {
      $node->field_item_document[LANGUAGE_NONE][0]['description'] = $text;
    }

    // Set the title to a trimmed version of the text:
    $node->title = moonmars_text_trim($text);
  }
}

/**
 * Common stuff to do if the item is inserted or updated from a channel.
 *
 * @param $node
 */
function moonmars_items_node_save($node) {
  // If the item was posted in a channel page:
  if ($node->type == 'item' && isset($GLOBALS['channel_nid']) && $GLOBALS['channel_nid']) {

    // Get the item:
    $item = Item::create($node);

    // Get the channel:
    $channel = Channel::create($GLOBALS['channel_nid']);

    // Update the alias:
    require_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'pathauto') . '/pathauto.inc';
    pathauto_create_alias('node', 'insert', $item->path(), array('node' => $node), 'item');

    // Connect the item to the channel (must be done after the alias is created).
    $channel->post($item, TRUE);
  }
}

/**
 * Implement hook_node_insert().
 */
function moonmars_items_node_insert($node) {
  moonmars_items_node_save($node);
}

/**
 * Implement hook_node_update().
 */
function moonmars_items_node_update($node) {
  moonmars_items_node_save($node);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AJAX callbacks

/**
 * Edit an item's text via AJAX.
 * @todo This is not currently used, need to build UI.
 *
 * @return string
 */
function moonmars_items_ajax_edit() {
  // Get the request parameters.
  // We use $_REQUEST so we can use POST from the form, but test using the query string (GET).
  $item_nid = (int) $_REQUEST['item_nid'];
  $text = trim($_REQUEST['text']);

  // Get the current member:
  $current_member = Member::currentMember();

  // Begin the data array:
  $data = array(
    'item_nid' => $item_nid,
    'text'     => $text,
  );

  // Check we have all the necessary params:
  if (!$item_nid || !$text || !$current_member) {
    // Encode result and send:
    $data['result'] = FALSE;
    $data['error'] = 'Invalid parameters';
    echo json_encode($data);
    return;
  }

  // Get the item:
  $item = Item::create($item_nid);

  // Check this member has permission to edit this item:
  if (!$current_member->canEditItem($item)) {
    // Complete data array, encode and send:
    $data['result'] = FALSE;
    $data['error'] = 'Access denied';
    echo json_encode($data);
    return;
  }

  /////////////////////////////////////
  // All good - update the item.

  // Update the item text:
  $item->field('field_item_text', LANGUAGE_NONE, 0, 'value', $text);

  // Save the item:
  $item->save();

  // Post/bump the item in all relevant channels:
  Channel::currentChannel()->post($item, FALSE);

  // Theme the item:
  $html = $item->render();

  // Complete data array, encode and send:
  $data['result'] = FALSE;
  $data['html'] = $html;
  echo json_encode($data);
}

/**
 * Delete an item via AJAX.
 *
 * @return string
 */
function moonmars_items_ajax_delete() {
  // Get the request parameters.
  $item_nid = isset($_REQUEST['item_nid']) ? ((int) $_REQUEST['item_nid']) : NULL;
//  $item_node_page = isset($_REQUEST['item_node_page']) ? ((bool) $_REQUEST['item_node_page']) : FALSE;

  // Get the current member:
  $current_member = Member::currentMember();

  // Begin the data array:
  $data = array(
    'item_nid' => $item_nid,
  );

  // Check we have all the necessary params:
  if (!$item_nid || !$current_member) {
    // Complete data array, encode and send:
    $data['result'] = FALSE;
    $data['error'] = 'Invalid parameters';
    echo json_encode($data);
    return;
  }

  // Get the item:
  $item = Item::create($item_nid);

  // Check this member has permission to delete this item:
  if (!$current_member->canDeleteItem($item)) {
    // Complete data array, encode and send:
    $data['result'] = FALSE;
    $data['error'] = 'Access denied';
    echo json_encode($data);
    return;
  }

  /////////////////////////////////
  // All good - unpublish the item.

  // Don't actually delete the item, just unpublish it:
  $item->unpublish();
  $item->save();

//  // If we're on the item's node page, rather than the channel page, get the destination link so we know where to
//  // send the user after the item is deleted.
//  if ($item_node_page) {
//    // Default to the channel where the item was initially posted.
//    // Allow for the possibility that the relationship to the original channel is gone (should never happen).
//    $originalChannel = $item->originalChannel();
//    if ($originalChannel) {
//      // Allow for the possibility that the relationship to the parent entity is gone (should never happen).
//      $parentEntity = $originalChannel->parentEntity();
//      if ($parentEntity) {
//        $destination = $parentEntity->alias();
//      }
//    }
//    // If we couldn't find the item's parent entity, return to the current member's profile:
//    if (!$destination) {
//      $destination = $current_member->alias();
//    }
//  }
//  if ($destination) {
//    $data['destination'] = "/$destination";
//  }

  // Complete data array, encode and send:
  $data['result'] = TRUE;
  echo json_encode($data);
  return;
}

/**
 * AJAX callback for removing items from your channel.
 */
function moonmars_items_ajax_remove() {
  // Get the request parameters.
  $item_nid = (int) $_REQUEST['item_nid'];

  // Get the current member:
  $current_member = Member::currentMember();

  // Get the current channel:
  $current_channel = Channel::currentChannel();

  // Begin the data array:
  $data = array(
    'item_nid' => $item_nid,
  );

  // Check we have all the necessary params:
  if (!$item_nid || !$current_member) {
    // Complete data array, encode and send:
    $data['result'] = FALSE;
    $data['error'] = 'Invalid parameters';
    echo json_encode($data);
    return;
  }

  // Get the item:
  $item = Item::create($item_nid);

  // Check this member has permission to remove this item:
  if (!$current_member->canRemoveItem($item, $current_channel)) {
    // Complete data array, encode and send:
    $data['result'] = FALSE;
    $data['error'] = 'Access denied';
    echo json_encode($data);
    return;
  }

  //////////////////////////////
  // All good - remove the item.

  // Remove the item from the current channel:
  moonmars_relationships_delete_relationships('has_item', 'node', $current_channel->nid(), 'node', $item_nid);

  // Complete data array, encode and send:
  $data['result'] = TRUE;
  echo json_encode($data);
  return;
}

/**
 * AJAX callback for rating items.
 */
function moonmars_items_ajax_rate() {
  $item_nid = (int) $_REQUEST['item_nid'];
  $rating = $_REQUEST['warning'];
  global $user;

  $rating_scores = moonmars_ratings_scores();

  // Check we have all the necessary params:
  if (!$item_nid || !array_key_exists($rating, $rating_scores) || !$user || !$user->uid) {
    // Create the data array:
    $data = array(
      'result'    => FALSE,
      'item_nid'  => $item_nid,
      'rating'    => $rating,
    );
    // Encode and send:
    echo json_encode($data);
    return;
  }

  // Load the item:
  $item = Item::create($item_nid);

  // Get the current score for the item:
  $score = (int) $item->field('field_score');

  // Check if the user already rated this:
  $rel_type = 'rated';
  $rels = moonmars_relationships_get_relationships($rel_type, 'user', $user->uid, 'node', $item_nid);
  if ($rels) {
    $rel = $rels[0];

    // Subtract the points for the previous rating:
    $old_rating_score = $rel->field_rating[LANGUAGE_NONE][0]['value'] * $rel->field_multiplier[LANGUAGE_NONE][0]['value'];
    $score -= $old_rating_score;

    // Remove the old rating relationship:
    relation_delete($rel->rid);
  }

  // Create the rating relationship:
  moonmars_relationships_create_relationship('rated', 'user', $user->uid, 'node', $item_nid, TRUE);

  // Add the points for the new rating:
  $member = Member::currentMember();
  $new_rating_score = $rating_scores[$rating] * $member->levelNum();
  $score += $new_rating_score;

  // Update the item's score:
  $item->field('field_score', LANGUAGE_NONE, 0, 'value', $score);
  $item->save();

  // Complete data array, encode and send:
  $data = array(
    'result'   => TRUE,
    'item_nid' => $item_nid,
    'rating'   => $rating,
    'score'    => $score,
  );
  echo json_encode($data);
  return;
}
