<?php

function moonmars_items_menu() {
  $items['ajax/item/edit'] = array(
    'page callback'    => 'moonmars_items_ajax_edit',
    'access callback'  => 'moonmars_items_can_edit',
    'type'             => MENU_CALLBACK,
  );

  // @todo For deleting items we need to use the same permissions as for edit - this is different from the usual
  // delete item permissions, which is only available to users with the 'administer items' permission.
  $items['ajax/item/delete'] = array(
    'page callback'    => 'moonmars_items_ajax_delete',
    'access arguments' => 'moonmars_items_can_delete',
    'type'             => MENU_CALLBACK,
  );

  $items['ajax/item/rate'] = array(
    'page callback'    => 'moonmars_items_ajax_rate',
    'access callback'  => 'node_access',
    'access arguments' => array(
      'update',
      1
    ),
    'type'             => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Create the form for posting new items in group channels.
 *
 * @todo Make this more generic so it can be used for user and event channels as well.
 *
 * @return array
 */
//function moonmars_items_form() {
//  $group_nid = arg(1);
//
//
//
////  $form = drupal_get_form('node_form_item');
//  $form['new-item'] = array(
//    '#type' => 'textarea',
//    '#title' => t('Share something:'),
//    '#resizable' => FALSE,
//    '#value' => '',
//    '#rows' => 2,
//  );
//  $form['new-item-link'] = array(
//    '#type' => 'textfield',
//    '#title' => t('Link:'),
//    '#value' => '',
//  );
//  $form['new-item-image'] = array(
//    '#type' => 'file',
//    '#title' => t('File:'),
//    '#value' => '',
//  );
//  $form['group-nid'] = array(
//    '#type' => 'hidden',
//    '#default_value' => $group_nid,
//  );
//  $form['post-button'] = array(
//    '#markup' => "<button id='post-button'>Post</button>",
//  );
//  return $form;
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Forms stuff

function moonmars_items_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'item_node_form' && moonmars_channels_is_embedded_channel_page()) {
    $entity_type = arg(0);
    $entity_id = (int) arg(1);
//    $channel_nid = moonmars_channels_get_channel($entity_type, $entity_id);

    // Set the title:
    switch ($entity_type) {
      case 'user':
        $account = user_load($entity_id);
        drupal_set_title('Member: ' . $account->name);
        break;

      case 'node':
        $node = node_load($entity_id);
        drupal_set_title(ucfirst($node->type) . ': ' . $node->title);
        break;
    }

    // Hide a bunch of shit we don't want to see:
    unset($form['title']);
    unset($form['field_score']);
    unset($form['additional_settings']);
    unset($form['revision_information']);
    unset($form['author']);
    unset($form['comment_settings']);
    unset($form['options']);
    unset($form['field_item_type'][LANGUAGE_NONE]['#title']);
    unset($form['field_item_text'][LANGUAGE_NONE][0]['value']['#title']);
    unset($form['field_item_link'][LANGUAGE_NONE][0]['#title']);
    unset($form['field_item_file'][LANGUAGE_NONE][0]['#title']);

//    dbg($form['field_item_type']);

    // Change the button label:
    $form['actions']['submit']['#value'] = t('Post');

    // Make the textarea non-resizable and only 2 rows high. We will use the autoresize() plugin on the client.
    $form['field_item_text']['#wysiwyg'] = FALSE;
    $form['field_item_text'][LANGUAGE_NONE][0]['value']['#resizable'] = FALSE;
    $form['field_item_text'][LANGUAGE_NONE][0]['value']['#rows'] = 2;

//    // Put the channel nid in a hidden field so we can access it.
//    $form['channel_nid'] = array(
//      '#type'          => 'hidden',
//      '#default_value' => $channel_nid,
//    );

    // Add an afterbuild handler so we can remove the submit buttons added in file_managed_file_process().
    $form['#after_build'][] = 'moonmars_items_form_after_build';

//    dpm($form);

    // Add a submit handler.
//    $form['#submit'][] = 'moonmars_items_form_submit';
  }
}

/**
 * After build handler for add new item form on group channel.
 *
 * @param array $form
 * @return array
 */
function moonmars_items_form_after_build($form) {
  // Remove the file field's submit buttons from the form:
  unset($form['field_item_file'][LANGUAGE_NONE][0]['upload_button']);
  unset($form['field_item_file'][LANGUAGE_NONE][0]['remove_button']);

  return $form;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Node hooks.

/**
 * Implement hook_node_presave().
 */
function moonmars_items_node_presave($node) {
  // Get the item text:
  $text = &$node->field_item_text[LANGUAGE_NONE][0]['value'];

  // If the item is a file, copy the entered text to the file description:
  if (isset($node->field_item_file[LANGUAGE_NONE][0]['fid']) && $node->field_item_file[LANGUAGE_NONE][0]['fid']) {
    $node->field_item_file[LANGUAGE_NONE][0]['description'] = $text;
  }

  // Set the title:
  $node->title = (strlen($text) <= 100) ? $text : (substr($text, 0, 97) . '...');
}

/**
 * Implement hook_node_insert().
 */
function moonmars_items_node_insert($node) {
  if ($node->type == 'item') {

    // Get the entity type:
    $entity_type = arg(0);
    if (!in_array($entity_type, array('user', 'node'))) {
      return;
    }

    // Get the entity id:
    $entity_id = arg(1);
    if (!is_uint($entity_id)) {
      return;
    }

    // Create the item object:
    $item = Item::create($node->nid);

    // Post the item in the current channel:
    Channel::currentChannel()->postItem($item, TRUE, FALSE);

    // Reload the group page:
    drupal_goto("$entity_type/$entity_id");
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Access callbacks.

/**
 * Check if the current user can post items in the current channel.
 *
 * @return bool
 */
function moonmars_items_can_post() {
  // Check basic permissions:
  if (!user_access('create item content')) {
    return FALSE;
  }

  global $user;
  $channel = Channel::currentChannel();
  $entity = $channel->parentEntityInfo();

  // Only the member can post in their own channel.
  if ($entity['entity_type'] == 'user') {
    return $entity['entity_id'] == $user->uid;
  }
  else {
    // $entity['entity_type'] == 'node'
    $node = node_load($entity['entity_id']);
    if ($node->type == 'group') {
      // Only members of the group can post in the group channel:
      return Group::create($node)->hasMember(Member::create($user));
    }
  }

  return FALSE;
}

/**
 * Check if the current user can edit or delete an item.
 *
 * @return bool
 */
function moonmars_items_can_edit_delete() {
  // We need a valid item id:
  $item_nid = (int) $_REQUEST['item_nid'];
  if (!$item_nid) {
    return FALSE;
  }
  $item = node_load($item_nid);
  if (!$item) {
    return FALSE;
  }

  global $user;

  // If this item doesn't belong to the user, they can't edit or delete it:
  if ($item->uid != $user->uid) {
    return FALSE;
  }

  // Ok so it's their item, but they can only edit or delete it if there haven't been any comments yet.
  $item = Item::create($item);
  if (!$item->commentCount()) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Check if the current user can edit a item.
 *
 * @return bool
 */
function moonmars_items_can_edit() {
  // Check basic permissions:
  if (user_access('administer content') || user_access('edit any item content')) {
    return TRUE;
  }
  if (!user_access('edit own item content')) {
    return FALSE;
  }

  return moonmars_items_can_edit_delete();
}

/**
 * Check if the current user can delete a item.
 *
 * @return bool
 */
function moonmars_items_can_delete() {
  // Check basic permissions:
  if (user_access('administer content') || user_access('delete any item content')) {
    return TRUE;
  }
  if (!user_access('delete own item content')) {
    return FALSE;
  }

  // Other than that, same rules as for editing:
  return moonmars_items_can_edit_delete();
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AJAX callbacks

/**
 * Edit an item's text via AJAX.
 *
 * @return string
 */
function moonmars_items_ajax_edit() {
  // Get the request parameters. Use $_REQUEST so we can use POST from the form but test using the query string.
  $item_nid = (int) $_REQUEST['item_nid'];
  $text = trim($_REQUEST['text']);
  global $user;

  // Create the data array:
  $data = array(
    'item_nid' => $item_nid,
    'text'     => $text,
  );

  // Check we have all the necessary params:
  if (!$item_nid || !$text || !$user || !$user->uid) {
    // Update the data array:
    $data['result'] = FALSE;

    // Encode and send:
    echo json_encode($data);
    return;
  }

  // Load the item:
  $item = Item::create($item_nid);
  $item->load();

  // Update the item text:
  $item->field('field_item_text', LANGUAGE_NONE, 0, 'value', $text);

  // Save the item:
  $item->save();

  // Post/bump the item in all relevant channels:
  Channel::currentChannel()->postItem($item, FALSE, FALSE);

  // Theme the item:
  $html = render_node($item->node());

  // Update the data array:
  $data['result'] = FALSE;
  $data['html'] = $html;

  // Encode and send:
  echo json_encode($data);
}

/**
 * AJAX callback for rating items.
 */
function moonmars_items_ajax_rate() {
  $item_nid = (int) $_REQUEST['item_nid'];
  $rating = $_REQUEST['warning'];
  global $user;

  $rating_scores = moonmars_ratings_scores();

  // Check we have all the necessary params:
  if (!$item_nid || !array_key_exists($rating, $rating_scores) || !$user || !$user->uid) {
    // Create the data array:
    $data = array(
      'result'    => FALSE,
      'item_nid'  => $item_nid,
      'rating'    => $rating,
    );
    // Encode and send:
    echo json_encode($data);
    return;
  }

  // Load the item:
  $item = Item::create($item_nid);
  $item->load();

  // Get the current score for the item:
  $score = (int) $item->field('field_score');

  // Check if the user already rated this:
  $rel_type = 'rated';
  $rels = moonmars_relationships_get_relationships($rel_type, 'user', $user->uid, 'node', $item_nid);
  if ($rels) {
    $rel = $rels[0];

    // Subtract the points for the previous rating:
    $old_rating_score = $rel->field_rating[LANGUAGE_NONE][0]['value'] * $rel->field_multiplier[LANGUAGE_NONE][0]['value'];
    $score -= $old_rating_score;

    // Remove the old rating relationship:
    relation_delete($rel->rid);
  }

  // Create the rating relationship:
  moonmars_relationships_create_relationship('rated', 'user', $user->uid, 'node', $item_nid, TRUE);

  // Add the points for the new rating:
  $member = Member::create($user->uid);
  $new_rating_score = $rating_scores[$rating] * $member->levelNum();
  $score += $new_rating_score;

  // Update the item's score:
  $item->field('field_score', LANGUAGE_NONE, 0, 'value', $score);
  $item->save();

  // Create the data array:
  $data = array(
    'result'    => TRUE,
    'item_nid'  => $item_nid,
    'rating'    => $rating,
    'score'     => $score,
  );
  // Encode and send:
  echo json_encode($data);
  return;
}
