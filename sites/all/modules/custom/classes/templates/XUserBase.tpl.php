<?php
// $Id$

/**
 * !! DO NOT EDIT THIS FILE !!
 * Instead, add your own methods and properties to the XUser class, which is
 * derived from this one.
 *
 * The XUserBase class is the base class for XUser. It wraps a regular user
 * object, providing an object-oriented interface to the Drupal user functions.
 *
 * This class also contains reference(s) to any content_profile profiles
 * for this user.
 *
 * This class follows the Factory pattern, which gives 2 main advantages:
 * - Users are cached, so there is never a duplicate object created for the same
 *   user.
 * - If an invalid parameter is passed to the create() method then FALSE is
 *   returned. If an ordinary constructor was used then we would have to either
 *   return an empty object or throw an exception, neither of which is ideal.
 *
 * @version <dt_generated>
 * @author shaunmoss
 */
abstract class XUserBase extends XEntity {

  //////////////////////////////////////////////////////////////////////////////
  // Static properties.

  /**
   * Static array of property information.
   *
   * @var array
   */
  protected static $propertyInfo = '(property_info)';

  /**
   * The id property for users.
   *
   * @var string
   */
  protected static $idProperty = 'uid';

  /**
   * Static cache of created XUser objects.
   *
   * @var array
   */
  protected static $cache = array();

  /**
   * Static array of profile content types.
   *
   * @var array
   */
  protected static $profileTypes;


  //////////////////////////////////////////////////////////////////////////////
  // Instance properties.

  /**
   * Have the user account fields (from the users table) been loaded from the
   * database?
   *
   * @var bool
   */
  protected $accountLoaded = FALSE;

  /**
   * Have the user's profile(s) been linked to this XUser object?
   *
   * @var bool
   */
  protected $profilesLinked = FALSE;

  /**
   * The user's profiles.
   *
   * @var array
   */
  protected $profiles = array();


  //////////////////////////////////////////////////////////////////////////////
  // Constructor.

  /**
   * Constructor is protected, as we're using the Factory pattern.
   */
  protected function __construct() {}


  //////////////////////////////////////////////////////////////////////////////
  // Static methods for creating and deleting objects.

  /**
   * Public factory method for creating new XUserBase objects.
   *
   * @param mixed $user
   *   Can be:
   *     - a uid
   *     - a username (new or existing)
   *     - a regular Drupal user account object
   *     - a record from the users table
   *     - a CCK user reference field
   *     - a XUserBase object
   *     - NULL, for a new user
   * @return object
   *   Or FALSE if there's any problem.
   */
  public static function create($user = NULL) {

    // Get the uid, if provided:
    $uid = classes_find_uid($user);

    // Check for valid uid:
    if (is_int($uid) && $uid < 0) {
      return FALSE;
    }

    // Check the XUser cache:
    if ($uid && self::inCache($uid)) {
      $xuser = self::$cache[$uid];
    }
    else {
      // Create the new object:
      $xuser = new XUser();

      // Do stuff related to whether or not the uid was provided:
      if ($uid) {
        // Set the uid:
        $xuser->uid = $uid;

        // This is an existing user:
        $xuser->new = FALSE;

        // Add the XUser to the cache:
        $xuser->addToCache();
      }
      else {
        // Set default values:
        // Assume active:
        $xuser->status = 1;

        // Created now:
        $xuser->created = time();

        // Generate a temporary password:
        $xuser->pass = user_password();

        // This is a new user:
        $xuser->new = TRUE;
      }
    }

    // Set the username if provided:
    if (is_string($user) && !classes_is_int($user)) {
      $xuser->name = $user;
    }
    elseif (is_object($user) || is_array($user)) {
      // Copy the $user parameter's fields:
      $xuser->copy($user);
    }

    return $xuser;
  }

  /**
   * Destroy a user.
   *
   * This includes destroying attached profiles.
   *
   * @param mixed $user
   *   This can be a uid, a normal Drupal user account object, XUserBase object,
   *   or a CCK user reference field.
   */
  public static function destroy($user) {
    // Get the uid:
    $uid = classes_find_uid($user);

    // Check for valid uid - note, *NEVER* delete OR block user 0 or 1!
    if ($uid <= 1) {
      return FALSE;
    }

    // Delete the user:
    // This will also cause any connected profiles to be deleted.
    user_delete(array(), $uid);

    // If the user object is in the cache, remove it:
    if (self::$cache[$uid]) {
      $xuser = self::$cache[$uid];

      // Unlink the user account:
      $xuser->entity = NULL;

      // Wipe all properties:
      $xuser->properties = array();
      $xuser->propertySet = array();

      // Unlink any profile objects so the garbage collector can clean them up:
      $xuser->profiles = array();
      $xuser->profilesLinked = FALSE;

      // No fields are loaded:
      $xuser->loaded = FALSE;

      // Remove the user from the cache:
      unset(self::$cache[$uid]);
    }
  }


  //////////////////////////////////////////////////////////////////////////////
  // Overload methods:

  /**
   * Passes the request through to the corresponding get method (getTitle(),
   * etc.), which will take care of loading fields from the database, etc.
   *
   * For example $page->title can be used instead of $page->getTitle().
   *
   * @param string $name
   * @return mixed
   */
  public function &__get($name) {
    // Store the current value of the ignoreErrors flag:
    $ignoreErrors = self::$ignoreErrors;

    // Turn off error reporting so that XEntityBase::_get() won't report any
    // error if the property is unknown.
    self::$ignoreErrors = TRUE;

    // Try the usual method of getting the property:
    $value = &parent::__get($name);

    // Restore the ignoreErrors flag:
    self::$ignoreErrors = $ignoreErrors;

    // If we found the property ok, return the value:
    if ($this->errorCode == CLASSES_ERROR_NONE) {
      return $value;
    }

    // The XUser object doesn't have this property, so let's scan through the
    // profile types to see if any of them have it.

    // Get the name of the matching 'get' method:
    $method = 'get' . ucfirst($name);
    foreach ($this->profiles as $type => $profile) {
      if (method_exists($profile, $method)) {
        // No error now:
        $this->errorCode == CLASSES_ERROR_NONE;
        // Call the method:
        return $profile->$method();
      }
    }

    // Unknown virtual property:
    $this->errorCode = CLASSES_ERROR_UNKNOWN_PROPERTY;
    // Report the error:
    if (!self::$ignoreErrors) {
      classes_error_property('get', $name, $this);
    }
    return NULL;
  }

  /**
   * We pass the request through to the corresponding set method, which will
   * take care of loading fields from the database, etc.
   *
   * For example, $country->code = 'AU' can be used instead of
   * $country->setCode('AU').
   *
   * @param string $name
   * @param mixed $value
   * @return object
   */
  public function __set($name, $value) {
    // Store the current value of the ignoreErrors flag:
    $ignoreErrors = self::$ignoreErrors;

    // Turn off error reporting:
    self::$ignoreErrors = TRUE;

    // Try the usual method of setting the property:
    $result = parent::__set($name, $value);

    // Restore the ignoreErrors flag:
    self::$ignoreErrors = $ignoreErrors;

    // If we found the property ok, return:
    if ($this->errorCode == CLASSES_ERROR_NONE) {
      return $this;
    }

    // The XUser object doesn't have this property, so let's scan through the
    // profile types to see if any of them have it.

    // Get the name of the matching 'set' method:
    $method = 'set' . ucfirst($name);

    // Get the different profile types:
    $profile_types = self::getProfileTypes();

    // Scan through the profile types looking for a matching method.
    foreach ($profile_types as $type) {

      // Get the profile class and check its validity:
      $class = classes_type_class_name($type);
      if (!$class || !class_exists($class) || !is_subclass_of($class, 'XNode')) {
        continue;
      }

      // Check if the class has the requested method:
      if (method_exists($class, $method)) {
        // Get the user's profile of this type, creating it if necessary:
        $profile = $this->getProfile($type, TRUE);
        if ($profile) {
          // No error now:
          $this->errorCode == CLASSES_ERROR_NONE;
          // Call the method:
          return $profile->$method($value);
        }
      }
    }

    // Unknown virtual property:
    $this->errorCode = CLASSES_ERROR_UNKNOWN_PROPERTY;
    // Report the error:
    if (!self::$ignoreErrors) {
      classes_error_property('set', $name, $this);
    }
    return $this;
  }

  /**
   * Handler for unknown methods. If a method is called that isn't known, see if
   * we can pass it through to one of the profile nodes.
   *
   * e.g. A call to $xuser->getFirstName() is passed to
   * $xuser->profiles['profile']->getFirstName();
   * Note, this only works if the profile content types have associated classes.
   *
   * @return mixed
   */
  public function __call($method, array $params) {
    // Get the different profile types:
    $profile_types = self::getProfileTypes();

    // Scan through the profile types looking for a matching method.
    // Note, for this to work a class file must exist for the profile type with
    // the matching method.
    foreach ($profile_types as $type) {

      // Get the profile type's class and check its validity:
      $class = classes_type_class_name($type);
      if (!$class || !class_exists($class) || !is_subclass_of($class, 'XNode')) {
        continue;
      }

      // Check if the profile class has the requested method:
      if (method_exists($class, $method)) {
        // Get the user's profile of this type, but don't create one if it doesn't exist:
        $profile = $this->getProfile($type);
        // If we have a profile object, call the method:
        if ($profile) {
          return call_user_func_array(array($profile, $method), $params);
        }
      }
    }

    // An invalid method was called, throw an error:
    classes_error_method($method, $this);
  }


  //////////////////////////////////////////////////////////////////////////////
  // Core instance methods.

  /**
   * Load the user account.
   *
   * @return object
   */
  public function load() {
    // We can't load the file without a uid:
    if (!$this->uid) {
      return FALSE;
    }

    // Load the user. The user_load() function will take care of any user load
    // hooks.
    $account = user_load($this->uid);

    // Check that we successfully loaded the user account:
    if (!$account) {
      return FALSE;
    }

    // Attach the loaded user object:
    $this->entity = $account;

    // The user account is now fully loaded. (However, profiles are not loaded.)
    $this->loaded = TRUE;

    // The user was loaded ok:
    return TRUE;
  }

  /**
   * Save a user.
   *
   * @return int
   *   Either SAVED_NEW, SAVED_UPDATED, SAVED_NOT or FALSE.
   */
  public function save() {
    // Copy any values from properties back into user account fields:
    $this->getEntity();

    // Default result:
    $result = SAVED_NOT;

    // Only save the user if it's new or if it's changed:
    if ($this->new || $this->dirty) {

      // Save the user account:
      $result = user_save($this->entity, $this->edit);
      $result = $result ? ($this->new ? SAVED_NEW : SAVED_UPDATED) : FALSE;

      if ($result) {
        // Reset the edit array:
        $this->edit = array();

        // The user is no longer new or dirty.
        $this->new = FALSE;
        $this->dirty = FALSE;

        // Add the user to the cache:
        $this->addToCache();
      }
    }

    // Save any linked profile nodes:
    if (is_array($this->profiles)) {
      foreach ($this->profiles as $profile) {
        // Make sure the profile is attached to the user, which will not be the
        // case if the user is new and therefore the uid has only just been set
        // by user_save().
        $profile->uid = $this->uid;
        $profile->save();
      }
    }

    // XUser saved successfully:
    return $status;
  }

  /**
   * Instance method for hard or soft deleting a user and attached profiles.
   *
   * By default, for safety, this method will only do a soft-delete, i.e. set
   * the status flag to 0 and save the user. This is the same as block().
   *
   * However, if the parameter $hard == TRUE then this method will do a
   * hard-delete, which means, delete the user from the database (along with any
   * attached profiles), and remove the XNode object from the cache.
   *
   * To implement cascading deletes for composition relationships, override this
   * method in your content type class.
   *
   * @param bool $hard = FALSE
   *   If TRUE, then delete; if FALSE, then block.
   */
  public function delete($hard = FALSE) {
    if ($hard) {
      // Hard-delete user account and attached profiles:
      parent::delete();
    }
    else {
      // Soft-delete profiles:
      $profiles = $this->getProfiles();
      foreach ($profiles as $profile) {
        $profile->delete();
      }
      // Soft-delete user account:
      $this->block();
    }
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods for working with the XUser object cache.

  /**
   * Get the static XUser object cache.
   *
   * @return array
   */
  public static function getCache() {
    return self::$cache;
  }

  /**
   * Clear the static XUser object cache.
   *
   * @return array
   */
  public static function clearCache() {
    self::$cache = array();
  }

  /**
   * Checks if a XUser is in the cache.
   *
   * @param mixed $user
   *   Can be a uid, user, XUser, CCK userreference field, etc.
   * @return bool
   */
  public static function inCache($user) {
    $uid = classes_find_uid($user);
    return $uid ? array_key_exists($uid, self::$cache) : FALSE;
  }

  /**
   * Add the XUser object to the static cache.
   */
  public function addToCache() {
    if ($this->uid) {
      self::$cache[$this->uid] = $this;
    }
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods for working with profiles.

  /**
   * Get all profile content types.
   *
   * @return array
   */
  public static function getProfileTypes() {
    if (!self::$profileTypes) {
      $type_objects = content_profile_get_types();
      // Go through the type objects and just get the type names:
      $types = array();
      foreach ($type_objects as $type_object) {
        $types[] = $type_object->type;
      }
      self::$profileTypes = $types;
    }
    return self::$profileTypes;
  }

  /**
   * Get the profile nid for a specified profile content type.
   *
   * @param string $type
   * @return int
   *   Or NULL if the profile node doesn't exist.
   */
  public function getProfileNid($type = 'profile') {
    if ($this->uid) {
      $sql = "SELECT nid FROM {node} WHERE uid = %d AND type = '%s'";
      $profile_nid = db_result(db_query($sql, $this->uid, $type));
    }
    return $profile_nid ? (int) $profile_nid : NULL;
  }

  /**
   * Get the user's profile node of the specified type.
   *
   * This does not fully load the profile node, it simply creates an object
   * and connects it to this XUser object. The profile node will not be loaded
   * until one of its fields is accessed.
   *
   * @param string $type = 'profile'
   *   The profile content type.
   * @param bool $create = FALSE
   *   Whether to create the profile if it doesn't already exist.
   * @return object
   */
  public function getProfile($type = 'profile', $create = FALSE) {

    // Check if we need to look up the profile nid:
    if (!array_key_exists($type, $this->profiles) || (!$this->profiles[$type] && $create)) {
      // Get the profile nid:
      $profile_nid = $this->getProfileNid($type);
      if ($profile_nid || $create) {

        // Create an XNode object for the profile and attach to the user.
        // If $profile_nid is NULL then a new profile node will be created.
        $this->profiles[$type] = XNode::create($profile_nid, $type);
        if ($this->profiles[$type]) {
          // Copy the uid and status:
          $this->profiles[$type]->uid = $this->uid;
          $this->profiles[$type]->status = $this->status;
        }
        else {
          // An XNode object could not be created (the most likely reason being
          // that no class exists for the profile content type).
          $this->profiles[$type] = NULL;
        }

      }
      else {
        // No profile of this type currently exists for this user:
        $this->profiles[$type] = NULL;
      }
    }

    // Return the profile of the given type:
    return $this->profiles[$type];
  }

  /**
   * Returns array with all profile nodes (XNode objects) currently connected to
   * this user.
   *
   * @return array
   */
  public function getProfiles() {

    // If we haven't linked the profiles yet, do it now:
    if (!$this->profilesLinked) {

      // Create and attach objects for each profile content type.
      $types = self::getProfileTypes();
      foreach ($types as $type) {
        $this->getProfile($type);
      }

      // Remember that we've done this:
      $this->profilesLinked = TRUE;
    }

    return $this->profiles;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods related to properties.

  /**
   * Set the value of a property. Note that changed values are stored in the
   * edit array, which we need to pass to user_save().
   *
   * Overrides XEntityBase method.
   *
   * @param string $property
   * @param mixed $value
   * @return object
   */
  public function setProperty($property, $value) {

    // Get the current value of the property, without autoloading:
    $current_value = $this->getProperty($property, FALSE);

    // If different, remember the changed value in the edit array:
    if ($value !== $current_value) {
      // Get the field name for this property:
      $info = $this->propertyInfo($property);
      // Store the modified value in the edit array:
      $this->edit[$info['field']] = $value;
    }

    // Call the base class method:
    return parent::setProperty($field, $value);
  }


  //////////////////////////////////////////////////////////////////////////////
  // Special accessor methods.

  /**
   * Get the regular Drupal user object referenced by the XUser object.
   * Alias for getEntity().
   *
   * @return object
   */
  public function getUser() {
    return $this->getEntity();
  }

  /**
   * Get a link to this XUser's page.
   *
   * @param string $text
   *   The link text, defaults to the user's username.
   * @return string
   */
  public function getLink($text = NULL) {
    if (is_null($text)) {
      $text = $this->name;
    }
    return l($text, "user/$this->uid");
  }

  /**
   * Get the value of the profilesLinked property.
   *
   * @return bool
   */
  public function getProfilesLinked() {
    return $this->profilesLinked;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods for updating a user's status.

  /**
   * Activate (unblock) a user.
   *
   * This differs from setStatus() in that the user account is saved, plus all
   * attached profiles are published.
   *
   * @return object
   *   The $this object.
   */
  public function activate($activate = TRUE) {
    // Convert $activate parameter to status value:
    $status = $activate ? 1 : 0;

    // Update the user status:
    $this->status = $status;

    // Publish all attached profiles:
    $profiles = $this->getProfiles();
    foreach ($profiles as $profile) {
      $profile->status = $status;
    }

    // Save the user and profiles:
    return $this->save();
  }

  /**
   * Block a user.
   *
   * This differs from setStatus() in that the user account is saved, plus all
   * attached profiles are unpublished.
   *
   * @return object
   *   The $this object.
   */
  public function block() {
    return $this->activate(FALSE);
  }


  //////////////////////////////////////////////////////////////////////////////
  // Static methods for getting info about all users of a given role.

  /**
   * Get all users of a given role and status as an array of options suitable
   * for a FAPI select element.
   *
   * @param string $role = NULL
   *   Can be a rid or a role name. If omitted then all users will be returned.
   * @param bool $active = NULL
   *   If omitted then both active and blocked users will be returned.
   * @return array
   */
  public static function getOptions($role = NULL, $active = NULL) {
    // Begin constructing SQL:
    $sql = "SELECT uid, name FROM {users}";
    $where = array();

    // Ignore user 0:
    $where[] = "uid > 0";

    // Check the role if set:
    if (!is_null($role)) {
      $role = self::loadRole($role);
      if ($role && $role->rid) {
        $where[] = "uid IN (SELECT uid FROM {users_roles} WHERE role = $role->rid)";
      }
    }

    // Check the status if set:
    if (!is_null($active)) {
      $where[] = "status = " . ($active ? 1 : 0);
    }

    // Add the WHERE clause:
    if ($where) {
      $sql .= " WHERE " . implode(" AND ", $where);
    }

    // Add the ORDER BY clause:
    $sql .= " ORDER by name";

    // Loop through results creating array of options:
    $options = array();
    $rs = db_query($sql);
    while ($rec = db_fetch_array($rs)) {
      $uid = (int) $rec['uid'];
      $name = $rec['name'];

      // Get the XUser:
      $xuser = self::create($uid);

      // Get the name without autoloading:
      $name2 = $xuser->getProperty('name', FALSE);
      if ($name2) {
        // The name of this user is set, so use that instead of the one just
        // loaded from the database:
        $name = $name2;
      }
      else {
        // The name of this user is not set, but since we've just loaded it, set
        // it now:
        $xuser->name = $name;
      }

      // Add option to array:
      $options[$uid] = $name;
    }

    return $options;
  }

  /**
   * Get the uids of all users of a given role and status.
   *
   * @param mixed $role = NULL
   *   Can be a rid or a role name. If omitted then all users will be returned.
   * @param bool $active = NULL
   *   If omitted then both active and blocked users will be returned.
   * @return array
   */
  public static function getUids($role = NULL, $active = NULL) {
    return array_keys(self::getOptions($role, $active));
  }

  /**
   * Get all users of a given role and status.
   *
   * @param string $role = NULL
   *   Can be a rid or a role name. If omitted then all users will be returned.
   * @param bool $active = NULL
   *   If omitted then both active and unactive users will be returned.
   * @return array
   */
  public static function getAll($role = NULL, $active = NULL) {
    // getUids() will find all the matching users, create objects for them, and
    // store them in the cache:
    $uids = self::getUids($role, $active);
    // Get an array of matching XUser objects from the cache:
    $xusers = array();
    foreach ($uids as $uid) {
      $xusers[] = self::$cache[$uid];
    }
    return $xusers;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods for working with user roles.

  /**
   * Given a role name or a rid, load the role.
   *
   * @param mixed $role
   * @return object
   *   The role as an object, or FALSE if the role is invalid.
   */
  public static function loadRole($role) {
    // Remember the roles we've loaded, to reduce database queries.
    static $roles = array();

    if (!array_key_exists($role, $roles)) {
      // Construct SQL based on whether the $role parameter is a rid or a role
      // name:
      $sql = "SELECT * FROM {role} WHERE " . (classes_is_int($role) ? "rid = %d" : "name = '%s'");
      // Load the role:
      $role_obj = db_fetch_object(db_query($sql, $role));
      // If the role loaded ok, remember it:
      if ($role_obj) {
        $roles[$role] = $role_obj;
      }
    }

    // Return the result:
    return array_key_exists($role, $roles) ? $roles[$role] : FALSE;
  }

  /**
   * Gets a user's roles (does not include 'anonymous user').
   *
   * @return array
   *   An array with role ids (rids) as keys and role names as values.
   */
  public function getRoles() {
    return $this->getEntity()->roles;
  }

  /**
   * Check if the user has a given role.
   *
   * @param mixed $role
   *   Can be a role id (rid) or a role name.
   * @return bool
   */
  public function hasRole($role) {
    $roles = $this->getRoles();
    if (classes_is_int($role)) {
      return array_key_exists($role, $roles);
    }
    else {
      return in_array($role, $roles);
    }
  }

  /**
   * Adds a given role to a user.
   *
   * @param mixed $role
   *   Can be a role id (rid) or a role name.
   * @return object
   *   The $this object.
   */
  public function addRole($role) {
    // Get the user's roles:
    $roles = $this->getRoles();
    // Get the role id and name from the parameter:
    $role = self::loadRole($role);
    // Add the role to the array, if not already there:
    if ($role && !array_key_exists($role->rid, $roles)) {
      // Copy the roles into the edit array if not already done:
      if (!array_key_exists('roles', $this->edit)) {
        $this->edit['roles'] = $roles;
      }
      // Add the role:
      $this->edit['roles'][$role->rid] = $role->name;
    }
    // Return the $this object so we can chain methods:
    return $this;
  }

  /**
   * Removes a given role from a user.
   *
   * @param mixed $role
   *   Can be a role id (rid) or a role name.
   * @return object
   *   The $this object.
   */
  public function removeRole($role) {
    // Get the user's roles:
    $roles = $this->getRoles();
    // Get the role id from the parameter:
    $role = self::loadRole($role);
    // Remove the role from the array, if it's there:
    if ($rid && array_key_exists($rid, $roles)) {
      // Copy the roles from the account into the edit array, if not already
      // done:
      if (!array_key_exists('roles', $this->edit)) {
        $this->edit['roles'] = $roles;
      }
      // Remove the role from the array:
      unset($this->edit['roles'][$rid]);
    }
    // Return the $this object so we can chain methods:
    return $this;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Accessor and mutator methods.
//getters_setters
}
