<?php
// $Id$

/**
 * !! DO NOT EDIT THIS FILE !!
 * Instead, add your own methods and properties to the XFile class, which is
 * derived from this one.
 *
 * The XFileBase class is the base class for XFile. It can be used to represent a
 * CCK XFile Field, or any other file in the files table.
 *
 * This class follows the Factory pattern, which gives 2 main advantages:
 * - XFile objects are cached, thus there is never a duplicate object created for
 *   the same file.
 * - If an invalid parameter is passed to the create() method then FALSE is
 *   returned. If an ordinary constructor was used then we would have to either
 *   return an empty object or throw an exception, neither of which is ideal.
 *
 * @version <dt_generated>
 * @author shaunmoss
 */
abstract class XFileBase extends XEntity {

  //////////////////////////////////////////////////////////////////////////////
  // Static properties.

  /**
   * Static array of property information.
   *
   * @var array
   */
  protected static $propertyInfo = '(property_info)';

  /**
   * The id property for files.
   *
   * @var string
   */
  protected static $idProperty = 'fid';

  /**
   * Static cache of created XFile objects.
   *
   * @var array
   */
  protected static $cache = array();


  //////////////////////////////////////////////////////////////////////////////
  // Constructor.

  /**
   * Constructor is protected, as we're using the Factory pattern.
   */
  protected function __construct() {}


  //////////////////////////////////////////////////////////////////////////////
  // Static methods for creating and deleting objects.

  /**
   * Public factory method for creating new XFileBase objects.
   *
   * @param mixed $file
   *   Can be:
   *     - a fid
   *     - a regular Drupal file object
   *     - a file path
   *     - a CCK FileField array
   *     - a record from the files table
   *     - a XFileBase object
   *     - NULL, for a new file
   * @return object
   *   Or FALSE if there's any problem.
   */
  public static function create($file = NULL) {
    // Get the fid:
    $fid = classes_find_fid($file);

    // Check it's valid:
    if ($fid < 0) {
      return FALSE;
    }

    // Check the XFile cache:
    if ($fid && self::inCache($fid)) {
      $xfile = self::$cache[$fid];
    }
    else {
      // Create the new object:
      $xfile = new XFile();
      
      // Do stuff related to whether or not the fid was provided:
      if ($fid) {
        // Set the fid:
        $xfile->fid = $fid;

        // This is an existing file:
        $xfile->new = FALSE;

        // Add the XFile to the cache:
        $xfile->addToCache();
      }
      else {
        // This is a new file:
        $xfile->new = TRUE;
      }
    }

    // Set provided fields:
    if (is_string($file) && !classes_is_int($file)) {
      // Assume $file is the path:
      $xfile->path = $file;
    }
    elseif (is_object($file) || is_array($file)) {
      // If an object or array was provided, copy its fields:
      $xfile->copy($file);
    }

    // If the file is new, set some default property values:
    if ($xfile->new) {

      // Set the uid if not set, and the user is logged in:
      if (!$xfile->propertySet['uid']) {
        global $user;
        if ($user->uid) {
          $xfile->uid = $user->uid;
        }
      }

      // Set the status if not set:
      if (!$xfile->propertySet['status']) {
        $xfile->status = FILE_STATUS_PERMANENT;
      }

      // Set the timestamp if not set:
      if (!$xfile->propertySet['timestamp']) {
        $xfile->timestamp = time();
      }
    }

    // Check how loaded the file is:
    $xfile->setLoaded();

    return $xfile;
  }

  /**
   * Destroy a file.
   *
   * That means:
   *   - Delete the file from the file system
   *   - Delete the corresponding record from the files table
   *
   * @param mixed $file
   *   Can be:
   *     - a fid
   *     - a regular Drupal file object
   *     - a file path
   *     - a CCK FileField array
   *     - a record from the files table
   *     - a XFileBase or XFile object
   * @param bool $force
   *   If TRUE, then the file will be deleted even if it's still referenced by
   *   nodes.
   * @return mixed
   *   TRUE if the delete succeeded, FALSE on error, or an array of references
   *   if the file is still referenced from nodes and was not deleted.
   *   @see field_file_delete().
   */
  public static function destroy($file, $force = FALSE) {
    // Get the XFile object:
    $xfile = XFile::create($file);

    // Check for valid XFile:
    if (!$xfile) {
      return FALSE;
    }

    // Try to delete the XFile.
    // Note, field_file_delete() invokes hook_file_delete().
    $result = field_file_delete($xfile->getEntity(), $force);
    if ($result !== TRUE) {
      // The delete did not succeed. The result will be either an array of
      // references or FALSE. Return this result:
      return $result;
    }

    // Unlink the inner file object, leave it for garbage collection:
    $xfile->entity = NULL;

    // Wipe all properties:
    $xfile->properties = array();
    $xfile->propertySet = array();

    // No fields are loaded:
    $xfile->loaded = FALSE;

    // Remove the XFile from the cache:
    unset(self::$cache[$xfile->fid]);

    // The delete succeeded:
    return TRUE;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Overloading methods.

  /**
   * Passes the request through to the corresponding get method (getTitle(),
   * etc.), which will take care of loading fields from the database, etc.
   *
   * For example $page->title can be used instead of $page->getTitle().
   *
   * @param string $name
   * @return mixed
   */
  public function &__get($name) {
    // Store the current value of the ignoreErrors flag:
    $ignoreErrors = self::$ignoreErrors;

    // Turn off error reporting so that XEntityBase::_get() won't report any
    // error if the property is unknown.
    self::$ignoreErrors = TRUE;

    // Try the usual method of getting the property:
    $value = &parent::__get($name);

    // Restore the ignoreErrors flag:
    self::$ignoreErrors = $ignoreErrors;

    // If we found the property ok, return the value:
    if ($this->errorCode == CLASSES_ERROR_NONE) {
      return $value;
    }

    // The property is unknown. Check the data array:
    if (array_key_exists($name, $this->data)) {
      // No error now:
      $this->errorCode == CLASSES_ERROR_NONE;
      // Get the value from the data array:
      return $this->data[$name];
    }

    // Unknown virtual property:
    $this->errorCode = CLASSES_ERROR_UNKNOWN_PROPERTY;
    // Report the error:
    if (!self::$ignoreErrors) {
      classes_error_property('get', $name, $this);
    }
    return NULL;
  }

  /**
   * We pass the request through to the corresponding set method, which will
   * take care of loading fields from the database, etc.
   *
   * For example, $country->code = 'AU' can be used instead of
   * $country->setCode('AU').
   *
   * @param string $name
   * @param mixed $value
   * @return object
   */
  public function __set($name, $value) {
    // Store the current value of the ignoreErrors flag:
    $ignoreErrors = self::$ignoreErrors;

    // Turn off error reporting:
    self::$ignoreErrors = TRUE;

    // Try the usual method of setting the property:
    $result = parent::__set($name, $value);

    // Restore the ignoreErrors flag:
    self::$ignoreErrors = $ignoreErrors;

    // If we found the property ok, return:
    if ($this->errorCode == CLASSES_ERROR_NONE) {
      return $this;
    }

    // The property is unknown. Store the value in the data array instead.
    // Make sure the data property is an array:
    if (!is_array($this->properties['data'])) {
      $this->properties['data'] = array();
    }

    // Add the value to the data array:
    $this->properties['data'][$name] = $value;
    $this->propertySet['data'] = TRUE;

    // No error now:
    $this->errorCode == CLASSES_ERROR_NONE;

    return $this;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Core instance methods.

  /**
   * Load the file record.
   *
   * @return object
   */
  public function load() {
    // We can't load the file without a fid:
    if (!$this->fid) {
      return FALSE;
    }

    // Load the file record.
    // (I changed this from using field_file_load() because the caching
    // mechanism in that module doesn't work very well.)
    $sql = "SELECT * FROM {files} WHERE fid = %d";
    $file = db_fetch_object(db_query($sql, $this->fid));

    // Check that we successfully loaded the file:
    if (!$file) {
      return FALSE;
    }

    // Invoke file load hooks:
    foreach (module_implements('file_load') as $module) {
      $function =  $module .'_file_load';
      $function($file);
    }

    // Set the entity to the loaded file object:
    $this->entity = $file;

    // The entity is now fully loaded:
    $this->loaded = TRUE;

    return $this;
  }

  /**
   * Save a file.
   *
   * @return int
   *   Either SAVED_NEW, SAVED_UPDATED, SAVED_NOT or FALSE.
   */
  public function save() {
    // Copy any values from properties back into fields:
    $this->getEntity();

    // Default result:
    $result = SAVED_NOT;

    // Only save the file if it's new or if it's changed:
    if ($this->new || $this->dirty) {

      // Insert or update the file record:
      $result = drupal_write_record('files', $this->entity, $this->new ? array() : 'fid');
      // $result will now be FALSE, SAVED_NEW or SAVED_UPDATED.

      if ($result) {
        // Code below copied from field_file_save_file() and field_file_save().
        // Invoke file save hooks:
        $hook = $this->new ? 'insert' : 'update';
        foreach (module_implements("file_$hook") as $module) {
          $function = $module . "_file_$hook";
          $function($this->entity);
        }

        // The file is no longer new or dirty.
        $this->new = FALSE;
        $this->dirty = FALSE;

        // Add the file to the cache:
        $this->addToCache();
      }
    }

    return $result;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods for working with the XFile object cache.

  /**
   * Get the static XFile object cache.
   *
   * @return array
   */
  public static function getCache() {
    return self::$cache;
  }

  /**
   * Clear the static XFile object cache.
   *
   * @return array
   */
  public static function clearCache() {
    self::$cache = array();
  }

  /**
   * Checks if a XFile is in the cache.
   *
   * @param mixed $file
   *   Can be a fid, file, XFile, CCK filefield, etc.
   * @return bool
   */
  public static function inCache($file) {
    $fid = classes_find_fid($file);
    return $fid ? array_key_exists($fid, self::$cache) : FALSE;
  }

  /**
   * Add the XFile object to the static cache.
   */
  public function addToCache() {
    if ($this->fid) {
      self::$cache[$this->fid] = $this;
    }
  }


  //////////////////////////////////////////////////////////////////////////////
  // Special accessor methods.

  /**
   * Get the regular Drupal file object referenced by the XFile object.
   * Alias for getEntity().
   *
   * @return object
   */
  public function getFile() {
    return $this->getEntity();
  }

  /**
   * Get the absolute path to the file on this server.
   *
   * @return string
   */
  public function getAbsolutePath() {
    return DRUPAL_ROOT . '/' . $this->path;
  }

  /**
   * Get a URL for this file.
   *
   * @return string
   */
  public function getUrl() {
    return file_create_url($this->path);
  }

  /**
   * Get a link to file.
   *
   * @param string $text
   *   The link text, defaults to the filename.
   * @return string
   */
  public function getLink($text = NULL) {
    if (!$text) {
      $text = $this->name;
    }
    return l($text, $this->url);
  }

  /**
   * Get the download link for the file. This is similar to getLink(),but with
   * an icon reflecting the MIME type.
   *
   * @return string
   */
  public function getDownloadLink() {
    // Make sure the file is fully loaded and get the entity:
    $file = $this->getEntity();

    // The theming function expects the file as an array, so cast it:
    return theme('filefield_file', (array) $file);
  }


  //////////////////////////////////////////////////////////////////////////////
  // Special mutator methods.

  /**
   * Set the value of the path property.
   *
   * @param string $value
   * @return object
   *   The $this object, for chaining method calls.
   */
  public function setPath($value) {
    $this->setProperty('path', $value);

    // Set the file name if not set:
    if (!$this->propertySet['name']) {
      $this->name = basename($this->path);
    }

    // Set the mime type if not set:
    if (!$this->propertySet['mime']) {
      $this->mime = classes_get_mime_type($this->path);
    }

    // Set the file size if not set:
    if (!$this->propertySet['size'] && file_exists($this->path)) {
      $this->size = filesize($this->path);
    }

    return $this;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Accessor and mutator methods.
//getters_setters
}
