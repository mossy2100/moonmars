<?php
// $Id$

/**
 * !! DO NOT EDIT THIS FILE !!
 * Instead, add your own methods and properties to the XNode class, which is
 * derived from this one.
 *
 * The XNodeBase class is the base class for XNode, which is in turn the base
 * class for all content type Base classes. It wraps a regular node object,
 * providing an object-oriented interface to the Drupal node functions.
 *
 * This class follows the Factory pattern, which gives 2 main advantages:
 * - Nodes are cached, thus there is never a duplicate object created for the
 *   same node.
 * - If an invalid parameter is passed to the create() method then FALSE is
 *   returned. If an ordinary constructor was used then we would have to either
 *   return an empty object or throw an exception, neither of which is ideal.
 *
 * @version <dt_generated>
 * @author shaunmoss
 */
abstract class XNodeBase extends XEntity {

  //////////////////////////////////////////////////////////////////////////////
  // Static properties.

  /**
   * Static array of property information.
   *
   * @var array
   */
  protected static $propertyInfo = '(property_info)';

  /**
   * The id property for nodes.
   *
   * @var string
   */
  protected static $idProperty = 'nid';

  /**
   * Static cache of created XNode objects.
   *
   * @var array
   */
  protected static $cache = array();


  //////////////////////////////////////////////////////////////////////////////
  // Instance properties.

  /**
   * Have the core node fields (from the node table) been loaded from the
   * database?
   *
   * @var bool
   */
  protected $coreLoaded = FALSE;

  /**
   * Have the revision fields (from the node_revisions table) been loaded from
   * the database?
   *
   * @var bool
   */
  protected $revisionLoaded = FALSE;

  /**
   * A reference to the creator of the node.
   *
   * @var XUser
   */
  protected $creator;


  //////////////////////////////////////////////////////////////////////////////
  // Constructor.

  /**
   * Constructor is protected, as we're using the Factory pattern.
   */
  protected function __construct() {}


  //////////////////////////////////////////////////////////////////////////////
  // Static methods for creating and deleting objects.

  /**
   * Public factory method for creating new objects.
   *
   * If the $type parameter is NULL, and if the type can't be determined from
   * the $node parameter, or if there's no valid class for the given type, then
   * the created object will have class XNode. This means the created object
   * won't have properties for CCK fields.
   *
   * @param mixed $node
   *   Can be:
   *     - a nid
   *     - a regular Drupal node object
   *     - a record from the node table
   *     - a CCK nodereference field
   *     - a XNodeBase object
   *     - NULL for a new node
   * @param string $type = NULL
   *   The content type.
   * @return object
   *   Or FALSE if there's any problem.
   */
  public static function create($node, $type = NULL) {
    // Get the nid, if provided:
    if (!is_null($node)) {
      $nid = classes_find_nid($node);
      // If we don't have a valid nid, we're done:
      if ($nid <= 0) {
        return FALSE;
      }
    }

    // Check if we already have an object for this node in the cache:
    if ($nid && self::inCache($nid)) {
      $xnode = self::$cache[$nid];
    }
    else {
      // If the content type isn't specified, see if we can find it:
      if (!$type) {
        if (is_object($node) && $node->type) {
          $type = $node->type;
        }
        elseif (is_array($node) && $node['type']) {
          $type = $node['type'];
        }
        elseif ($nid) {
          // Get the type from the node record:
          $rec = classes_get_node_record($nid);
          if ($rec && $rec['type']) {
            $type = $rec['type'];
          }
        }
      }

      // Get the class name, defaulting to XNode if no type provided.
      if (!$type) {
        $class = 'XNode';
      }
      else {
        $class = classes_type_class_name($type);
        // If a valid class doesn't exist for this type then use XNode.
        if (!$class || !class_exists($class) || !is_subclass_of($class, 'XNodeBase')) {
          $class = 'XNode';
        }
      }

      // Create the new object:
      $xnode = new $class();

      // Set the type if provided:
      if ($type) {
        $xnode->type = $type;
      }

      // Do stuff related to whether or not the nid was provided:
      if ($nid) {
        // Set the nid:
        $xnode->nid = $nid;

        // This is an existing node:
        $xnode->new = FALSE;

        // Add the XNode to the cache:
        $xnode->addToCache();
      }
      else {
        // Set default values:
        global $user;
        $xnode->uid = $user->uid ? $user->uid : 1;
        $xnode->status = 1;

        // Default timestamp values:
        $now = time();
        $xnode->created = $now;
        $xnode->changed = $now;
        
        // This is a new node:
        $xnode->new = TRUE;
      }
    }

    // If an object or array was provided, copy its fields:
    if (is_object($node) || is_array($node)) {
      $xnode->copy($node);
    }

    // Copy fields from the node record if we loaded it:
    if ($rec) {
      $xnode->copy($rec);
    }

    return $xnode;
  }

  /**
   * Destroy a node.
   *
   * If you want cascading deletes, i.e. deletion of nodes referenced by this
   * node, then override this function (not in an autogenerated base class
   * though). e.g. implement Country::destroy()
   *
   * Alternatively, override the delete() method.
   *
   * Note, this method does not delete the object itself - it just removes the
   * node from the database.
   *
   * @param mixed $node
   *   Can be:
   *     - a nid
   *     - a regular Drupal node object
   *     - a XNodeBase or XNode object
   *     - anything else from which a nid can be extracted (@see create())
   */
  public static function destroy($node) {
    // Get the nid from the param:
    $nid = classes_find_nid($node);

    // Check for valid nid:
    if ($nid <= 0) {
      return;
    }

    // Set the uid of the node to 1. This is a workaround the Drupal "feature"
    // whereby node_delete() doesn't work if the node's uid references a user
    // account that doesn't exist any more. uid = 1 is the superuser account,
    // which we can safely assume will always be there. This might have to be
    // removed, as it effectively bypasses node access control.
    db_query("UPDATE {node} SET uid = 1 WHERE nid = %d", $nid);

    // Delete the node:
    node_delete($nid);

    // If the node object is in the cache, remove it:
    if (self::$cache[$nid]) {
      $xnode = self::$cache[$nid];

      // Unlink the inner node object, leave it for garbage collection:
      $xnode->entity = NULL;

      // Wipe all properties:
      $xnode->properties = array();
      $xnode->propertySet = array();

      // No fields are loaded:
      $xnode->coreLoaded = FALSE;
      $xnode->revisionLoaded = FALSE;
      $xnode->loaded = FALSE;

      // Remove the node from the cache:
      unset(self::$cache[$nid]);
    }
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods related to loading and saving of nodes.

  /**
   * Calculate the loaded flags.
   */
  public function setLoaded() {
    // If we don't have an entity, then it isn't loaded at all:
    if (!$this->entity) {
      $this->coreLoaded = FALSE;
      $this->revisionLoaded = FALSE;
      $this->loaded = FALSE;
      return;
    }

    // Default to fully loaded.
    $core_fields_loaded = TRUE;
    $revision_fields_loaded = TRUE;
    $cck_fields_loaded = TRUE;

    // Look through fields to see if any are missing:
    $property_info = $this->propertyInfo();
    foreach ($property_info as $property => $info) {
      // If a field is missing, set the corresponding loaded flag to FALSE:
      $field = $info['field'];
      if (!property_exists($this->entity, $field)) {
        switch ($info['source']) {
          case 'node':
            $core_fields_loaded = FALSE;
            break;

          case 'node_revisions':
            $revision_fields_loaded = FALSE;
            break;

          case 'content':
            $cck_fields_loaded = FALSE;
            break;
        } // switch
      } // if
    } // foreach

    // Set loaded flags:
    $this->coreLoaded = $core_fields_loaded;
    $this->revisionLoaded = $this->coreLoaded && $revision_fields_loaded;
    $this->loaded = $this->revisionLoaded && $cck_fields_loaded;
  }

  /**
   * Check to see if the entity is loaded, and if not, load it.
   *
   * @param $level = 'all'
   *   The level of loading required: 'core', 'revision' or 'all' (default).
   */
  public function ensureLoaded($level = 'all') {
    switch ($level) {
      case 'core':
        if (!$this->coreLoaded) {
          $this->loadCore();
        }
        break;

      case 'revision':
        if (!$this->revisionLoaded) {
          $this->loadRevision();
        }
        break;

      default:
        if (!$this->loaded) {
          $this->load();
        }
        break;
    }
  }

  /**
   * Load the node's core fields - this ignores CCK fields and just loads a
   * record from the node table. Very fast, circumvents loading entire node when
   * only e.g. the title or status is needed. Ignores revisions.
   *
   * @return object
   *   Returns $this unless there's an error, then FALSE.
   */
  public function loadCore() {
    if (!$this->nid) {
      // Can't load the node without a nid:
      return FALSE;
    }

    // Load the core fields:
    $rec = classes_get_node_record($this->nid);

    // Check that we successfully loaded the fields:
    if (!$rec) {
      return FALSE;
    }

    // Copy the loaded fields into the entity:
    $this->copy($rec);

    // The core fields are now loaded:
    $this->coreLoaded = TRUE;

    return $this;
  }

  /**
   * Loads the latest node revision - this ignores CCK fields and just loads a
   * record from the node_revisions table.
   *
   * @return object
   */
  public function loadRevision() {
    // If the core fields are already loaded then just load the record from the
    // node_revisions table:
    if ($this->coreLoaded) {
      if ($this->vid) {
        $sql = "
          SELECT *, v.timestamp AS revision_timestamp, v.uid AS revision_uid
          FROM {node_revisions} v
          WHERE vid = %d";
        $rec = db_fetch_array(db_query($sql, $this->vid));
      }
    }
    else {
      // Load both core and revision fields for the latest node revision:
      if ($this->nid) {
        $sql = "
          SELECT *, v.timestamp AS revision_timestamp, v.uid AS revision_uid
          FROM {node} n JOIN {node_revisions} v USING (vid)
          WHERE n.nid = %d";
        $rec = db_fetch_array(db_query($sql, $this->nid));
      }
    }

    // Check that we successfully loaded the fields:
    if (!$rec) {
      return FALSE;
    }

    // Copy the loaded fields into the entity:
    $this->copy($rec);

    // The revision fields are now loaded:
    $this->revisionLoaded = TRUE;

    return $this;
  }

  /**
   * Load the node.
   *
   * @param bool $bypass_cache = FALSE
   *   If set to TRUE, bypasses caching in the node and content modules, thus
   *   forcing load of the node from the database.
   * @return bool
   *   TRUE on success, FALSE on failure.
   */
  public function load($bypass_cache = FALSE) {
    // We can't load the node without a nid:
    if (!$this->nid) {
      return FALSE;
    }

    if ($bypass_cache) {
      // If we don't have the vid yet, get it now:
      if (!$this->vid) {
        $this->vid = (int) db_result(db_query("SELECT vid FROM {node} WHERE nid = %d", $this->nid));
      }

      // Remove cached CCK data:
      if (function_exists('content_cache_tablename')) {
        db_query("DELETE FROM " . content_cache_tablename() . " WHERE cid = 'content:$this->nid:$this->vid'");
      }

      // Load the node. The node_load() function will take care of any node
      // load hooks.
      $node = node_load($this->nid, $this->vid);
    }
    else {
      // Load the node:
      $node = node_load($this->nid);
    }

    // Check that we successfully loaded the node:
    if (!$node) {
      return FALSE;
    }

    // Set the entity to the loaded node:
    $this->entity = $node;

    // The entity is now fully loaded:
    $this->loaded = TRUE;

    // If we're bypassing the cache then we will assume the programmer wants the
    // latest field values from the database, so unset all property values:
    if ($bypass_cache) {
      $this->propertySet = array();
    }

    return TRUE;
  }

  /**
   * This method will load a set of fields - either core, revision or all - from
   * the database.
   *
   * The supplied $field parameter is used to determine which set of fields to
   * load and therefore which load method to call.
   *
   * Overrides method in XEntityBase.
   *
   * @param string $field
   * @return mixed
   */
  protected function loadField($field) {
    // Get the field info:
    $info = $this->getFieldInfo($field);

    // Select the loaded flag and load method based on the field source:
    switch ($info['source']) {
      case 'node':
        $loaded = $this->coreLoaded;
        $load_method = 'loadCore';
        break;

      case 'node_revisions':
        $loaded = $this->revisionLoaded;
        $load_method = 'loadRevision';
        break;

      default:
        $loaded = $this->loaded;
        $load_method = 'load';
        break;
    }

    // Call the appropriate load method:
    $this->$load_method();
  }

  /**
   * Check if a node exists in the database.
   *
   * @return bool
   */
  public function inDB() {
    return $this->loadCore();
  }

  /**
   * Save a node.
   *
   * @return int
   *   Either SAVED_NEW, SAVED_UPDATED or SAVED_NOT. Unlike other entity save()
   *   methods this one never returns FALSE because node_save() doesn't.
   */
  public function save() {
    // Copy any values from properties back to entity fields.
    $this->getEntity();

    // Default result:
    $result = SAVED_NOT;

    // Only save the user if it's new or if it's been modified:
    if ($this->new || $this->dirty) {
      // Save the node. The node_save() function will invoke hook_presave() and
      // either hook_insert() or hook_update().
      node_save($this->entity);

      // Determine result:
      $result = $this->new ? SAVED_NEW : SAVED_UPDATED;

      // The node is no longer new or dirty.
      $this->new = FALSE;
      $this->dirty = FALSE;

      // Add the node to the cache:
      $this->addToCache();
    }

    return $result;
  }

  /**
   * Instance method for hard or soft deleting a node.
   *
   * By default, for safety, this method will only do a soft-delete, i.e. set
   * the status flag to 0 and save the node. This is the same as unpublish().
   *
   * However, if the parameter $hard == TRUE then this method will do a
   * hard-delete, which means, delete the node from the database, and remove the
   * XNode object from the cache.
   *
   * To implement cascading deletes for composition relationships, override this
   * method in your content type class.
   *
   * @param bool $hard = FALSE
   *   If TRUE, then delete; if FALSE, then unpublish.
   */
  public function delete($hard = FALSE) {
    if ($hard) {
      parent::delete();
    }
    else {
      $this->unpublish();
    }
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods for working with the XNode object cache.

  /**
   * Get the static XNode object cache.
   *
   * @return array
   */
  public static function getCache() {
    return self::$cache;
  }

  /**
   * Clear the static XNode object cache.
   *
   * @return array
   */
  public static function clearCache() {
    self::$cache = array();
  }

  /**
   * Checks if a XNode is in the cache.
   *
   * @param mixed $node
   *   Can be a nid, node, XNode, CCK nodereference field, etc.
   * @return bool
   */
  public static function inCache($node) {
    $nid = classes_find_nid($node);
    return $nid ? array_key_exists($nid, self::$cache) : FALSE;
  }

  /**
   * Add the XNode object to the static cache.
   */
  public function addToCache() {
    if ($this->nid) {
      self::$cache[$this->nid] = $this;
    }
  }


  //////////////////////////////////////////////////////////////////////////////
  // Special accessor methods.

  /**
   * Get the regular Drupal node object referenced by the XNode object.
   * Alias for getEntity().
   *
   * @return object
   */
  public function getNode() {
    return $this->getEntity();
  }

  /**
   * Get the creator of the node as a XUser object.
   *
   * @return XUser
   */
  public function getCreator() {
    if (!$this->creator) {
      $this->creator = XUser::create($this->uid);
    }
    return $this->creator;
  }

  /**
   * Get the path to this XNode's page.
   *
   * @return string
   */
  public function getPath() {
    return drupal_get_path_alias("node/" . $this->nid);
  }

  /**
   * Get a link to this XNode's page, using the title as the link text.
   *
   * @param string $text
   *   The link text, defaults to the node's title.
   * @return string
   */
  public function getLink($text = NULL) {
    if (is_null($text)) {
      $text = $this->title;
    }
    return l($text, "node/$this->nid");
  }

  /**
   * Get the value of the coreLoaded property.
   *
   * @return bool
   */
  public function isCoreLoaded() {
    return $this->coreLoaded;
  }

  /**
   * Get the value of the revisionLoaded property.
   *
   * @return bool
   */
  public function isRevisionLoaded() {
    return $this->revisionLoaded;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods for updating a node's status.

  /**
   * Publish a node.
   * This differs from setStatus(1) because the node is saved.
   *
   * @param bool $publish = TRUE
   * @return object
   *   The $this object.
   */
  public function publish($publish = TRUE) {
    // Update the status:
    $this->status = $publish ? 1 : 0;
    // Save the node:
    return $this->save();
  }

  /**
   * Unpublish a node.
   * This differs from setStatus(0) because the node is saved.
   *
   * @return object
   *   The $this object.
   */
  public function unpublish() {
    return $this->publish(FALSE);
  }


  //////////////////////////////////////////////////////////////////////////////
  // Static methods for getting info about all nodes of a given type.

  /**
   * Get all nodes of a given type and status as an array of options suitable
   * for a FAPI select element.
   *
   * @param string $type = NULL
   *   If omitted or NULL then nids of all content types will be returned.
   * @param bool $published = NULL
   *   If omitted or NULL then both published and unpublished nodes will be
   *   returned.
   * @return array
   */
  public static function getOptions($type = NULL, $published = NULL) {
    // Begin constructing SQL:
    $sql = "SELECT nid, title FROM {node}";
    $where = array();

    // Filter by type if requested:
    if (!is_null($type)) {
      $where[] = "type = '" . db_escape_string($type) . "'";
    }

    // Filter by status flag if requested:
    if (!is_null($published)) {
      $where[] = "status = " . ($published ? 1 : 0);
    }

    // Add where clause:
    if (!empty($where)) {
      $sql .= " WHERE " . implode(" AND ", $where);
    }

    // Add order by clause:
    $sql .= " ORDER by title";

    // Loop through node records creating options array:
    $options = array();
    $rs = db_query($sql);
    while ($rec = db_fetch_array($rs)) {
      $nid = (int) $rec['nid'];
      $title = $rec['title'];

      // Get the XNode:
      $xnode = self::create($nid, $type);

      // Get the title without autoloading:
      $title2 = $xnode->getProperty('title', FALSE);
      if ($title2) {
        // The title of this node is set, so use that instead of the one just
        // loaded from the database:
        $title = $title2;
      }
      else {
        // The title of this node is not set, but since we've just loaded it,
        // set it now:
        $xnode->title = $title;
      }

      // Add option to array:
      $options[$nid] = $title;
    }

    return $options;
  }

  /**
   * Get the nids of all nodes of a given type and status.
   *
   * @param string $type = NULL
   *   If omitted or NULL then nids of all content types will be returned.
   * @param bool $published = NULL
   *   If omitted or NULL then both published and unpublished nodes will be
   *   returned.
   * @return array
   */
  public static function getNids($type = NULL, $published = NULL) {
    return array_keys(self::getOptions($type, $published));
  }

  /**
   * Get XNode objects for all nodes of a given type and status.
   *
   * @param string $type = NULL
   * @param bool $published = NULL
   *   If omitted then both published and unpublished nodes will be returned.
   * @return array
   */
  public static function getAll($type = NULL, $published = NULL) {
    // getNids() will find all the matching nodes, create objects for them, and
    // store them in the cache:
    $nids = self::getNids($type, $published);
    // Get an array of matching XNode objects from the cache:
    $xnodes = array();
    foreach ($nids as $nid) {
      $xnodes[] = self::$cache[$nid];
    }
    return $xnodes;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Accessor and mutator methods.
//getters_setters
}
