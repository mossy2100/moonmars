<?php
// $Id$

/**
 * !! DO NOT EDIT THIS FILE !!
 * Instead, add your own methods and properties to the XTerm class, which is
 * derived from this one.
 *
 * The XTermBase class is the base class for XTerm. It wraps a regular taxonomy
 * term object, providing an object-oriented interface to the Drupal taxonomy
 * functions.
 *
 * This class follows the Factory pattern, which gives 2 main advantages:
 * - Terms are cached, thus there is never a duplicate object created for the
 *   same term.
 * - If an invalid parameter is passed to the create() method then FALSE is
 *   returned. If an ordinary constructor was used then we would have to either
 *   return an empty object or throw an exception, neither of which is ideal.
 *
 * @version <dt_generated>
 * @author shaunmoss
 */
abstract class XTermBase extends XEntity {

  //////////////////////////////////////////////////////////////////////////////
  // Static properties.

  /**
   * Static array of property information.
   *
   * @var array
   */
  protected static $propertyInfo = '(property_info)';

  /**
   * The id property for terms.
   *
   * @var string
   */
  protected static $idProperty = 'tid';

  /**
   * Static cache of created XTerm objects.
   *
   * @var array
   */
  protected static $cache = array();


  //////////////////////////////////////////////////////////////////////////////
  // Constructor.

  /**
   * Constructor is protected, as we're using the Factory pattern.
   */
  protected function __construct() {}


  //////////////////////////////////////////////////////////////////////////////
  // Static methods for creating and deleting objects.

  /**
   * Public factory method for creating new XTerm objects.
   *
   * @param mixed $term
   *   Can be:
   *     - a tid
   *     - a regular Drupal term object
   *     - a record from the term_data table
   *     - a CCK taxonomy term reference field
   *     - a XTermBase object
   *     - the term name (new or existing)
   *     - NULL for a new term
   * @param string $vocab
   *   Can be:
   *     - a vocabulary id (vid)
   *     - vocabulary name
   *     - NULL if the vocabulary is specified in the $term parameter
   *   @todo Also support Vocabulary objects.
   * @return object
   *   Or FALSE if there's any problem.
   */
  public static function create($term = NULL, $vocab = NULL) {
    // Try to find the vid from the $vocab or the $term:
    if ($vocab) {
      $vid = classes_find_vid($vocab);
    }
    elseif (is_object($term) && $term->vid) {
      $vid = (int) $term->vid;
    }
    elseif (is_array($term) && $term['vid']) {
      $vid = (int) $term['vid'];
    }

    // Get the tid if provided:
    $tid = classes_find_tid($term, $vid);

    // Make sure ids are valid:
    if ($tid < 0 || $vid < 0) {
      return FALSE;
    }

    // Check the XTerm cache:
    if ($tid && self::inCache($tid)) {
      $xterm = self::$cache[$tid];
    }
    else {
      // Create the new object:
      $xterm = new XTerm();

      // Do stuff related to whether or not the tid was provided:
      if ($tid) {
        // Set the tid:
        $xterm->tid = $tid;

        // This is an existing term:
        $xterm->new = FALSE;

        // Add the XTerm to the cache:
        $xterm->addToCache();
      }
      else {
        // This is a new term:
        $xterm->new = TRUE;
      }
    }

    // Set the vocabulary id:
    if ($vid) {
      $xterm->vid = $vid;
    }

    // Set provided fields:
    if (is_string($term) && !classes_is_int($term)) {
      // Copy the provided name:
      $xterm->name = $term;
    }
    elseif (is_object($term) || is_array($term)) {
      // Copy the $term parameter's fields:
      $xterm->copy($term);
    }

    return $xterm;
  }

  /**
   * Destroy a term.
   *
   * @param mixed $term
   *   This can be a tid, a normal Drupal taxonomy term object, XTermBase, or
   *   CCK term reference field.
   */
  public static function destroy($term) {
    // Get the tid:
    $tid = classes_find_tid($term);

    // Check for valid tid:
    if ($tid <= 0) {
      return FALSE;
    }

    // Delete the term:
    taxonomy_del_term($tid);

    // If the term object is in the cache, remove it:
    if (self::$cache[$tid]) {
      $xterm = self::$cache[$tid];

      // Unlink the inner term object, leave it for garbage collection:
      $xterm->entity = NULL;

      // Wipe all properties:
      $xterm->properties = array();
      $xterm->propertySet = array();

      // No fields are loaded:
      $xterm->loaded = FALSE;

      // Remove the term from the cache:
      unset(self::$cache[$tid]);
    }
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods related to loading and saving of terms.

  /**
   * Load the term.
   *
   * @return object
   */
  public function load() {
    // We can't load the term without a tid:
    if (!$this->tid) {
      return FALSE;
    }

    // Load the term. There is no term load hook.
    $term = taxonomy_get_term($this->tid);

    // Check that we successfully loaded the term:
    if (!$term) {
      return FALSE;
    }

    // Set the entity to the loaded term:
    $this->entity = $term;

    // The entity is now fully loaded:
    $this->loaded = TRUE;

    return $this;
  }

  /**
   * Save a term.
   *
   * @return int
   *   Either SAVED_NEW, SAVED_UPDATED, SAVED_NOT or FALSE.
   */
  public function save() {
    // Copy any values from properties back into term fields:
    $this->getEntity();

    // Default result:
    $result = SAVED_NOT;

    // Only save the term if it's new or if it's changed:
    if ($this->new || $this->dirty) {

      // Update term record:
      $result = drupal_write_record('term_data', $this->entity, $this->new ? array() : 'tid');

      if ($result) {
        // Invoke term save hooks:
        $hook = $result == SAVED_NEW ? 'insert' : 'update';
        $term = (array) $this->entity;
        module_invoke_all('taxonomy', $hook, 'term', $term);
        $this->entity = (object) $term;

        // The term is no longer new or dirty.
        $this->new = FALSE;
        $this->dirty = FALSE;

        // Add the term to the cache:
        $this->addToCache();
      }
    }

    return $result;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods for working with the XTerm object cache.

  /**
   * Get the static XTerm object cache.
   *
   * @return array
   */
  public static function getCache() {
    return self::$cache;
  }

  /**
   * Clear the static XTerm object cache.
   *
   * @return array
   */
  public static function clearCache() {
    self::$cache = array();
  }

  /**
   * Checks if a XTerm is in the cache.
   *
   * @param mixed $term
   *   Can be a tid, term, XTerm, CCK taxonomy reference, etc.
   * @return bool
   */
  public static function inCache($term) {
    $tid = classes_find_tid($term);
    return $tid ? array_key_exists($tid, self::$cache) : FALSE;
  }

  /**
   * Add the object to the static cache.
   */
  public function addToCache() {
    if ($this->tid) {
      self::$cache[$this->tid] = $this;
    }
  }


  //////////////////////////////////////////////////////////////////////////////
  // Special accessor methods.

  /**
   * Get the regular Drupal term object referenced by the XTerm object.
   * Alias for getEntity().
   *
   * @return object
   */
  public function getTerm() {
    return $this->getEntity();
  }

  /**
   * Get a link to this XTerm's page.
   *
   * @param string $text
   *   The link text, defaults to the term's name.
   * @return string
   */
  public function getLink($text = NULL) {
    if (is_null($text)) {
      $text = $this->name;
    }
    return l($text, "taxonomy/term/$this->tid");
  }


  //////////////////////////////////////////////////////////////////////////////
  // Static methods for getting info about all terms of a given role.

  /**
   * Get all terms from a given vocabulary as an array of options suitable for a
   * FAPI select element.
   *
   * @param mixed $vocab
   *   Can be a vocabulary id (vid) or a vocabulary name.
   * @return array
   */
  public static function getOptions($vocab) {
    // Get the vid:
    $vid = classes_find_vid($vocab);

    // Get the terms:
    $sql = "SELECT tid, name FROM {term_data} WHERE vid = %d ORDER by weight, name";
    $rs = db_query($sql, $vid);

    // Loop through results creating array of options:
    $options = array();
    while ($rec = db_fetch_array($rs)) {
      $tid = (int) $rec['tid'];
      $name = $rec['name'];

      // Check if the name of this term has changed without saving:
      if (self::$cache[$tid]) {
        $xterm = self::$cache[$tid];
        // Note, we don't use getName() here, because we don't want to load the
        // term. Just check if we have the name or not.
        if (array_key_exists('name', $xterm->properties)) {
          // Use the name from the XTerm object instead of the one from the
          // database:
          $name = $xterm->properties['name'];
        }
        else {
          // The name is not set, set it now:
          $xterm->name = $name;
        }
      }
      else {
        // Create a new XTerm object - this will add it to the cache:
        $xterm = self::create($tid);
        $xterm->name = $name;
      }

      // Add option to array:
      $options[$tid] = $name;
    }
    return $options;
  }

  /**
   * Get the tids of all terms in a given vocabulary.
   *
   * @param mixed $vocab
   *   Can be a vocabulary id (vid) or a vocabulary name.
   * @return array
   */
  public static function getTids($vocab) {
    return array_keys(self::getOptions($vocab));
  }

  /**
   * Get all terms in a given vocabulary.
   *
   * @param mixed $vocab
   *   Can be a vocabulary id (vid) or a vocabulary name.
   * @return array
   */
  public static function getAll($vocab) {
    // getTids() will find all the matching terms, create objects for them and
    // store them in the cache:
    $tids = self::getTids($vocab);
    // Get an array of matching XTerm objects from the cache:
    $Terms = array();
    foreach ($tids as $tid) {
      $Terms[] = self::$cache[$tid];
    }
    return $Terms;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Methods for working with vocabularies.

  /**
   * Set the vocabulary from a vocabulary id, name, array (record) or object.
   *
   * @param mixed $vocab
   * @return object
   */
  public function setVocabulary($vocab) {
    $this->vid = classes_find_vid($vocab);
    return $this;
  }

  /**
   * Get the vocabulary.
   * At present this just returns the vocabulary name, but it should return a
   * Vocabulary object.
   *
   * @return string
   */
  public function getVocabulary() {
    $vid = $this->vid;
    if ($vid) {
      return db_result(db_query("SELECT name FROM {vocabulary} WHERE vid = %d", $vid));
      // @todo Implement the Vocabulary class.
//      return Vocabulary::create($vid);
    }
    return NULL;
  }


  //////////////////////////////////////////////////////////////////////////////
  // Accessor and mutator methods.
//getters_setters
}
