<?php
// $Id$

/**
 * @file
 * Some useful helper functions used by the classes module as well as generated
 * classes.
 */


/**
 * Get the paths to all the classes generated by the classes module.
 */
function classes_paths($reset = FALSE) {
  // Cache the result so we won't need to rerun this scan every time.
  static $class_paths = NULL;

  // If we haven't scanned the classes folder yet, do it now:
  if (!$class_paths || $reset) {
    global $_classes_dir;

    // Recursively scan the classes directory:
    $classes = file_scan_directory("$_classes_dir", '\.class\.php$',
      array('.', '..', 'CVS', '.svn'), 0, TRUE, 'name');

    // Remove the ".class" from the end of the filenames:
    $class_paths = array();
    foreach ($classes as $class => $class_info) {
      $class = basename($class, '.class');
      $class_paths[$class] = $class_info->filename;
    }
    ksort($class_paths);
  }

  return $class_paths;
}

/**
 * Check if a class file exists in the classes folder or a subfolder.
 *
 * @param string $class
 * @param bool $reset
 * @return bool
 */
function classes_class_exists($class, $reset = FALSE) {
  $class_paths = classes_paths($reset);
  return array_key_exists($class, $class_paths);
}

/**
 * Check for the existence of a derived class and its base class.
 *
 * @param string $type
 * @return array
 */
function classes_check_existence($type, $category = 'types') {

  // Normalize $category parameter:
  $entity = in_array(strtolower($category), array('entities', 'entity'));
  $category = $entity ? CLASSES_CATEGORY_ENTITIES : CLASSES_CATEGORY_TYPES;

  // Get the class names:
  $class = classes_class_name($type, $category);
  $base_class = $class . 'Base';

  // Get existence of classes:
  $class_exists = classes_class_exists($class);
  $base_class_exists = classes_class_exists($base_class);

  return array(
    'class' => array('name' => $class, 'exists' => $class_exists),
    'base class' => array('name' => $base_class, 'exists' => $base_class_exists),
  );
}

/**
 * Get the field information for a given content type.
 *
 * @param string $type
 * @return array
 */
function classes_get_cck_fields($type, $reset = FALSE) {
  static $properties;

  // If we don't have the properties for this content type yet, or if $reset is
  // TRUE, get them now:
  if (!isset($properties[$type]) || $reset) {

    // Get the CCK fields for this content type, in the same order as on the
    // "Manage fields" page.
    $sql = "
      SELECT
        c.field_name AS field,
        c.type_name AS content_type,
        c.label,
        c.property_name AS property,
        f.type AS field_type,
        f.global_settings,
        f.multiple,
        f.module
      FROM {content_node_field_instance} c
        LEFT JOIN {content_node_field} f USING (field_name)
        LEFT JOIN {content_group_fields} gf USING (field_name)
        LEFT JOIN {content_group} g USING (group_name)
      WHERE c.type_name = '%s'
      ORDER BY IF(g.weight IS NULL, c.weight, g.weight), c.weight";

    $rs = db_query($sql, $type);
    $properties[$type] = array();
    while ($rec = db_fetch_array($rs)) {
      $rec['global_settings'] = unserialize($rec['global_settings']);
      $properties[$type][$rec['field']] = $rec;
    }
  }

  return $properties[$type];
}

/**
 * Get all the class names for content types.
 *
 * @return array
 */
function classes_get_type_classes() {
  static $classes;

  // If we don't have the properties for this content type yet, get them now:
  if (!isset($classes)) {
    // Get the content types:
    $rs = db_query("SELECT type, name, class_name FROM {node_type} ORDER BY type");
    $classes = array();
    while ($rec = db_fetch_array($rs)) {
      $classes[$rec['type']] = $rec;
    }
  }

  return $classes;
}

/**
 * Tell the user which classes were generated.
 *
 * @param array $classes
 */
function classes_generated_message($classes) {
  $classes = array_keys($classes);
  drupal_set_message(t("The following class files were generated: %classes",
    array('%classes' => implode(', ', $classes))));
}

/**
 * Delete a generated class file.
 *
 * @param string $class
 * @param bool $delete_base_class_also = FALSE
 * @return bool
 *   TRUE if the class file was deleted, otherwise FALSE.
 */
function classes_delete_class($class, $delete_base_class_also = FALSE) {
  $paths = classes_paths();

  // Delete the class:
  if (isset($paths[$class]) && is_file($paths[$class])) {
    $result = unlink($paths[$class]);
  }
  else {
    $result = FALSE;
  }

  // Delete the base class also, if requested:
  if ($delete_base_class_also) {
    $result = $result && classes_delete_class($class . 'Base');
  }

  return $result;
}

/**
 * Useful function to convert between different casing conventions.
 *
 * @todo Move this function to the Drupal 6 API Extension library (to be adapted
 * from the drupal.php file).
 *
 * @param string $str
 *   The string to convert.
 * @param int $from_case
 *   One of the CASE constants above.
 * @param int $to_case
 *   One of the CASE constants above.
 * @return string
 */
function classes_convert_case($str, $from_case, $to_case) {
  // Get an array of words, doesn't matter whether upper, lower or mixed case.
  switch ($from_case) {
    case CLASSES_LOWER_CASE:
    case CLASSES_UPPER_CASE:
      $words = explode('_', $str);
      break;

    case CLASSES_CAMEL_CASE:
    case CLASSES_TITLE_CASE:
      // Keep track of whether the character is a digit, since a switch from
      // letter to digit or vice-versa will be treated as a word boundary:
      $prev_is_digit = FALSE;
      $n = 0;
      $words = array();
      for ($i = 0; $i < strlen($str); $i++) {
        $ch = $str[$i];
        $is_digit = ctype_digit($ch);
        // Detect word boundary:
        if ($i == 0 || ctype_upper($ch) || ($prev_is_digit != $is_digit)) {
          $n++;
        }
        // Let's initialise the new word so we don't get a notice:
        if (!isset($words[$n])) {
          $words[$n] = '';
        }
        // Add the character to the word:
        $words[$n] .= $ch;
        // Next character:
        $prev_is_digit = $is_digit;
      }
      break;
  }

  // Convert from array of words into string:
  switch ($to_case) {
    case CLASSES_LOWER_CASE:
      return implode('_', array_map('strtolower', $words));

    case CLASSES_UPPER_CASE:
      return implode('_', array_map('strtoupper', $words));

    case CLASSES_CAMEL_CASE:
      $words = array_map('strtolower', $words);
      $first_word = array_shift($words);
      return $first_word . implode(array_map('ucfirst', $words));

    case CLASSES_TITLE_CASE:
      return implode(array_map('ucfirst', array_map('strtolower', $words)));
  }
}

/**
 * Check that an identifier (in this case, a property or class name) is valid
 * according to PHP's rules.
 *
 * @param string $name
 * @return bool
 */
function classes_valid_identifier($name) {
  // Must be a string of greater than 0 length:
  if (!is_string($name) || $name == '') {
    return FALSE;
  }

  // Must start with a letter:
  if (!ctype_alpha($name[0])) {
    return FALSE;
  }

  // Must only contain letters, digits and underscores:
  $len = strlen($name);
  for ($i = 1; $i < $len; $i++) {
    if (!ctype_alnum($name[$i]) && $name[$i] != '_') {
      return FALSE;
    }
  }

  // All good:
  return TRUE;
}

/**
 * Get the entity class names (XEntity, XNode, XUser, etc.)
 *
 * @return array
 */
function classes_entity_class_names() {
  // Get the entity class names:
  $entities = classes_entities();
  $entity_classes = array();
  foreach ($entities as $entity => $info) {
    $entity_classes[$entity] = 'X' . ucfirst($entity);
  }
  return $entity_classes;
}

/**
 * Get the class name corresponding to a given entity.
 *
 * @param string $entity
 * @return string
 */
function classes_entity_class_name($entity) {
  return 'X' . ucfirst($entity);
}

/**
 * Get the default class name for a content type, by converting from lower-case
 * to TitleCase. If the class name is needed for an entity, append 'Type'.
 *
 * @param string $type
 * @return string
 */
function classes_default_class_name($type) {
  $class = classes_convert_case($type, CLASSES_LOWER_CASE, CLASSES_TITLE_CASE);

  // If the class name is needed for an entity, append 'Type':
  if (in_array($class, classes_entity_class_names())) {
    $class .= 'Type';
  }

  return $class;
}

/**
 * Get the class name corresponding to a given content type.
 *
 * @param string $type
 * @param bool $reset = FALSE
 *   If TRUE, the static cache of class names will be regenerated.
 * @return string
 */
function classes_type_class_name($type, $reset = FALSE) {
  static $class_names;

  if (!$class_names || $reset) {
    $rs = db_query("SELECT type, class_name FROM {node_type} ORDER BY type");
    while ($rec = db_fetch_array($rs)) {
      if ($rec['class_name']) {
        $class_names[$rec['type']] = $rec['class_name'];
      }
    }
  }

  // If we don't have a class name for this type (as is the case when testing),
  // return the default:
  if (!$class_names[$type]) {
    $class_names[$type] = classes_default_class_name($type);
  }

  return $class_names[$type];
}

/**
 * Return the class name for a given entity or content type.
 *
 * @param string $type
 * @param string $category = 'types'
 * @return string
 */
function classes_class_name($type, $category = 'types') {
  $entity = in_array(strtolower($category), array('entities', 'entity'));
  return $entity ? classes_entity_class_name($type) : classes_type_class_name($type);
}

/**
 * Make sure the node_type table has the class_name column,
 * and for any types without a class name, initialise to the default.
 */
function classes_set_default_class_names() {
  // Check that the class_name column has been added:
  $rs = db_query("DESC {node_type}");
  $class_name_found = FALSE;
  while ($rec = db_fetch_array($rs)) {
    if ($rec['Field'] == 'class_name') {
      $class_name_found = TRUE;
      break;
    }
  }

  // If the field isn't there, add it:
  if (!$class_name_found) {
    // Add the class_name column to the node_type table:
    $spec = array(
      'type' => 'varchar',
      'length' => 32,
      'not null' => TRUE,
      'default' => '',
    );
    db_add_field($ret, 'node_type', 'class_name', $spec);
  }

  // Set the default class name for any unset fields:
  $rs = db_query("
    SELECT type, class_name
    FROM {node_type}
    WHERE class_name = '' OR class_name IS NULL");
  while ($rec = db_fetch_array($rs)) {
    $class = classes_default_class_name($rec['type']);
    $sql = "
      UPDATE {node_type} SET
        class_name = '%s'
      WHERE type = '%s'";
    db_query($sql, $class, $rec['type']);
  }
}

/**
 * Check if a given content type is for user profiles.
 *
 * @param string $type
 * @return bool
 */
function classes_is_profile_type($type) {
  return (bool) variable_get("content_profile_use_$type", FALSE);
}

/**
 * Get the default property name from a field name by removing the 'field_'
 * prefix and also the content type if present, then converting to camelCase.
 *
 * @todo Also check that there isn't another virtual property with the same name
 * for this content type.
 *
 * @param string $field
 * @return string
 */
function classes_default_property_name($field, $type) {
  $property = $field;

  // Remove the "field_" prefix, if present:
  if (substr($property, 0, 6) == 'field_') {
    $property = substr($property, 6);
  }

  // If the field name starts with the content type then remove that as well, as
  // long as the resultant property name isn't restricted.
  // e.g. if the type is 'profile' and the field is 'field_profile_first_name'
  // then the property name will simply be 'first_name'.
  // However if the type is 'booking' and the field is 'field_booking_status',
  // the the property name will be 'bookingStatus', not 'status', which is a
  // core node field.
  $type_prefix = $type . '_';
  if (substr($property, 0, strlen($type_prefix)) == $type_prefix) {
    $trim_property = substr($property, strlen($type_prefix));

    // Check that the trimmed property name doesn't collide with any reserved
    // property names.
    $reserved = classes_reserved_properties($type);
    if (!in_array($trim_property, $reserved)) {
      // Looks ok, so use it:
      $property = $trim_property;
    }
  }

  // Convert to camelCase in line with Drupal coding standards:
  return classes_convert_case($property, CLASSES_LOWER_CASE, CLASSES_CAMEL_CASE);
}

/**
 * Make sure the content_node_field_instance table has the property_name column,
 * and for any fields without a property name, initialise to the default.
 */
function classes_set_default_property_names() {
  // Check that the property_name column has been added:
  $rs = db_query("DESC {content_node_field_instance}");
  $property_name_found = FALSE;
  while ($rec = db_fetch_array($rs)) {
    if ($rec['Field'] == 'property_name') {
      $property_name_found = TRUE;
      break;
    }
  }

  // If the field isn't there, add it:
  if (!$property_name_found) {
    // Add the property_name column to the content_node_field table:
    $spec = array(
      'type' => 'varchar',
      'length' => 32,
      'not null' => TRUE,
      'default' => '',
    );
    db_add_field($ret, 'content_node_field_instance', 'property_name', $spec);
  }

  // Set the default property name for any unset fields:
  $rs = db_query("
    SELECT field_name, type_name
    FROM {content_node_field_instance}
    WHERE property_name = '' OR property_name IS NULL");
  while ($rec = db_fetch_array($rs)) {
    $property = classes_default_property_name($rec['field_name'], $rec['type_name']);
    $sql = "
      UPDATE {content_node_field_instance} SET
        property_name = '%s'
      WHERE field_name = '%s' AND type_name = '%s'";
    db_query($sql, $property, $rec['field_name'], $rec['type_name']);
  }
}

/**
 * Make sure the node_type and content_node_field_instance table have the extra
 * columns, and that any unset class and property names are initialised to the
 * default.
 */
function classes_set_default_names() {
   classes_set_default_class_names();
   classes_set_default_property_names();
}

/**
 * Get a record from the node table.
 *
 * @param int $nid
 */
function classes_get_node_record($nid) {
  return db_fetch_array(db_query("SELECT * FROM {node} WHERE nid = %d", $nid));
}

/**
 * Get the global settings for a CCK field.
 *
 * @param string $field
 * @return array
 */
function classes_get_global_settings($field) {
  // Get the global settings for this field from the database:
  $sql = "SELECT global_settings FROM {content_node_field} WHERE field_name = '%s'";
  $settings = db_result(db_query($sql, $field));

  // If we found the settings, unserialize them into an array. Otherwise return
  // FALSE.
  return $settings ? unserialize($settings) : FALSE;
}

/**
 * Get the widget settings for a CCK field.
 *
 * @param string $field
 * @param string $type
 * @return array
 */
function classes_get_widget_settings($field, $type) {
  // Get the global settings for this field from the database:
  $sql = "
    SELECT widget_settings
    FROM {content_node_field_instance}
    WHERE field_name = '%s' AND type_name = '%s'";
  $settings = db_result(db_query($sql, $field, $type));

  // If we found the settings, unserialize them into an array. Otherwise return
  // FALSE.
  return $settings ? unserialize($settings) : FALSE;
}

/**
 * Format an array in the Drupal style.
 * Does not support arrays containing objects.
 *
 * @param array $array
 * @param int $indent
 * @return string
 */
function classes_format_array($array, $indent = 0) {
  if (empty($array)) {
    return "array()";
  }
  $spaces = str_repeat(' ', $indent);
  $lines = array();
  $lines[] = "array(";
  foreach ($array as $key => $value) {
    $line = "$spaces  '$key' => ";
    if (is_null($value)) {
      $line .= 'NULL';
    }
    elseif (is_bool($value)) {
      $line .= $value ? 'TRUE' : 'FALSE';
    }
    elseif (is_numeric($value)) {
      $line .= $value;
    }
    elseif (is_string($value)) {
      $line .= "'" . addslashes($value) . "'";
    }
    elseif (is_array($value)) {
      $line .= classes_format_array($value, $indent + 2);
    }
    $line .= ",";
    $lines[] = $line;
  }
  $lines[] = "$spaces)";
  return implode("\n", $lines);
}


////////////////////////////////////////////////////////////////////////////////
// Functions for converting values to fields or properties.

/**
 * Converts a datetime value, which may be an integer, string, DateTime,
 * XDateTime, XDateTimeRange or array, into a CCK datetime field.
 *
 * @param mixed $datetime
 * @return array
 */
function classes_datetime_to_cck_field($datetime) {
  // Get the from and to datetimes from the value:
  if ($datetime instanceof XDateTimeRange) {
    $from = $datetime->from;
    $to = $datetime->to;
  }
  elseif (is_array($datetime) && count($datetime) == 2) {
    // Array has two values, which we assume are the From and To datetimes:
    list($from, $to) = array_values($datetime);
  }
  else {
    // It's a single value, so we just set the From datetime.
    $from = $datetime;
    $to = NULL;
  }

  // Make sure the from datetime is a XDateTime:
  if (!$from instanceof XDateTime) {
    $from = new XDateTime($from);
  }

  // Make sure the to datetime is NULL or a XDateTime:
  if (!is_null($to) && !$to instanceof XDateTime) {
    $to = new XDateTime($to);
  }

  // Return the CCK array:
  return array(
    'value' => $from->iso,
    'value2' => $to ? $to->iso : NULL,
  );
}

/**
 * Converts the given value to the specified entity, if necessary.
 * If the value cannot be converted, or doesn't need to be, it's returned as-is.
 * Verifies that the entity class specified is actually provided by the classes
 * module (by checking that it's a subclass of XEntity) and not by some other
 * part of the app.
 *
 * @param mixed $value
 * @param string $entity_class
 * @return object
 */
function classes_value_to_entity($entity_class, $value) {
  if (class_exists($entity_class) && is_subclass_of($entity_class, 'XEntity') && !is_a($value, $entity_class)) {

    // Call the create() method of the entity class:
    $entity = call_user_func(array($entity_class, 'create'), $value);

    // Check if we got a valid entity object:
    if ($entity) {
      return $entity;
    }
  }

  // Could not convert, or didn't need to, so return original value:
  return $value;
}

/**
 * Checks if the array is a classical 0-indexed array, i.e. has sequential
 * integer keys starting from 0.
 *
 * @param array $a
 * @return bool
 */
function classes_is_numeric_array($a) {
  if (!is_array($a)) {
    return FALSE;
  }
  return array_keys($a) === array_keys(array_values($a));
}

/**
 * Convert the provided value to an array.
 *
 * @param mixed $value
 * @return array
 */
function classes_convert_to_array($value) {
  if (is_array($value)) {
    // Simply return the array:
    return $value;
  }
  elseif (is_object($value)) {
    // Convert object to array:
    return (array) $value;
  }
  elseif (is_string($value)) {
    // If $value is a string, try unserializing it:
    $x = @unserialize($value);
    if (is_array($x)) {
      return $x;
    }
  }
  // Make an array with 1 element:
  return array($value);
}

/**
 * Convert the provided value to the required type/class for the property.
 *
 * @param mixed $value
 * @param array $property_info
 * @return mixed
 */
function classes_value_to_property($value, $property_info) {

  // Extract the value from a CCK array:
  if (is_array($value) && array_key_exists('value', $value) && !array_key_exists('value2', $value)) {
    $value = $value['value'];
  }

  // A NULL value means a NULL value for the property:
  if (is_null($value)) {
    return NULL;
  }

  // Convert the type/class based on the field type:
  switch ($property_info['type']) {
    case 'int':
      return (int) $value;

    case 'float':
      return (float) $value;

    case 'string':
      return (string) $value;

    case 'array':
      return classes_convert_to_array($value);

    case 'XDateTimeRange':
      return $value instanceof XDateTimeRange ? $value : new XDateTimeRange($value);

    case 'XDateTime':
      return $value instanceof XDateTime ? $value : new XDateTime($value);

    case 'XNode':
    case 'XUser':
    case 'XTerm':
    case 'XFile':
    case 'XLocation':
      return classes_value_to_entity($property_info['type'], $value);

    case 'XLink':
      return $value instanceof XLink ? $value : new XLink($value);

    default:

      // Check if it's a content type class:
      if (is_subclass_of($property_info['type'], 'XNode')) {
        return classes_value_to_entity($property_info['type'], $value);
      }

      // If this is an unknown or custom type, then for now we'll just make the
      // property value the same as the CCK value.
      return $value;
  }
}

/**
 * Convert each element in the provided array of values to the required
 * type/class for the property.
 *
 * @param array $values
 * @param array $property_info
 * @return array
 */
function classes_values_to_property($values, $property_info) {
  // Ensure the given value is an array with 0-indexed numeric keys:
  if (is_null($values)) {
    $values = array();
  }
  elseif (!classes_is_numeric_array($values)) {
    $values = array($values);
  }

  // Loop through provided values, converting each to the property value:
  $property_values = array();
  foreach ($values as $value) {
    $property_values[] = classes_value_to_property($value, $property_info);
  }

  // If this is a multiple value, we want the array, otherwise just the first
  // and presumably only value:
  return $property_info['multiple'] ? $property_values : $property_values[0];
}

/**
 * Convert a property value to a field value.
 *
 * @param mixed $value
 * @param bool $cck
 *   If the target field is a CCK field.
 * @param string $type
 * @return mixed
 */
function classes_value_to_field($value, $property_info) {
  switch ($property_info['type']) {
    case 'int':
    case 'float':
    case 'string':
      // These types may or may not indicate a CCK field:
      return $property_info['source'] == 'content' ? array('value' => $value) : $value;

    case 'XDateTimeRange':
      // At present, this class is used purely for CCK date, datetime and
      // datestamp fields. This may change in the future.
      return classes_datetime_to_cck_field($value);

    case 'XDateTime':
      // At present, this class is used purely for non-CCK timestamp fields.
      // This may change in the future.
      return classes_find_timestamp($value);

    case 'XNode':
      // Always CCK:
      return array('nid' => classes_find_nid($value));

    case 'XUser':
      // Always CCK:
      return array('uid' => classes_find_uid($value));

    case 'XTerm':
      // Always CCK:
      return array('value' => classes_find_tid($value));

    case 'XFile':
      // Always CCK:
      if ($value instanceof XFileBase) {
        return array(
          'fid' => $value->fid,
          'list' => $value->list,
          'data' => $value->data,
          'uid' => $value->uid,
          'filename' => $value->name,
          'filepath' => $value->path,
          'filemime' => $value->mime,
          'filesize' => $value->size,
          'status' => $value->status,
          'timestamp' => $value->timestamp->timestamp,
        );
      }
      else {
        return array('fid' => classes_find_fid($value));
      }

    case 'XLocation':
      if ($value instanceof XLocationBase) {
        return (array) $value->location;
      }
      else {
        return array('lid' => classes_find_lid($value));
      }

    case 'XLink':
      // Always CCK:
      if ($value instanceof XLink) {
        return array(
          'url' => $value->url,
          'title' => $value->title,
          'attributes' => $value->attributes,
        );
      }
      else {
        return $value;
      }

    default:

      // Check if it's a content type class:
      if (is_subclass_of($property_info['type'], 'XNode')) {
        return array('nid' => classes_find_nid($value));
      }

      // If this is an unknown or custom type, then by default the property
      // value is the same as the field value.
      return $value;
  }
}

/**
 * Evaluate whether a CCK field is empty.
 *
 * @param array $cck_field
 * @return bool
 */
function classes_is_empty_cck_field($cck_field) {
  // Check that we have an array containing only one array.
  if (!is_array($cck_field) || count($cck_field) > 1 || !isset($cck_field[0]) || !is_array($cck_field[0])) {
    return FALSE;
  }

  // Check that all elements in the array are NULL or '':
  $attributes = array_values($cck_field[0]);
  foreach ($attributes as $attribute) {
    if (!is_null($attribute) && $attribute !== '') {
      return FALSE;
    }
  }

  // Only NULLs found.
  return TRUE;
}


////////////////////////////////////////////////////////////////////////////////
// Functions for working with PHP version numbers.

/**
 * Converts a version number in the form "x.yy.zz" into a float (x.yyzz).
 *
 * @param string $version
 * @return float
 */
function classes_version_to_float($version) {
  $php_ver = explode('.', strval($version));
  // Set minor version numbers to hundredths and ten-thousandths,
  return $php_ver[0] + ($php_ver[1] / 100) + ($php_ver[2] / 10000);
}

/**
 * Get the current PHP version as a float.
 * Version 5.3 will be returned as 5.03, and version 5.10 will be returned as
 * 5.10, so that versions can be compared numerically with correct results.
 * Version 5.3.1, for example, will be returned as 5.0301.
 * Obviously if minor version numbers exceed 99 this function will need to be
 * modified.
 *
 * @return float
 */
function classes_php_version() {
  static $php_ver = NULL;
  // Get the current PHP version as a float, if not already done:
  if (!isset($php_ver)) {
    $php_ver = classes_version_to_float(phpversion());
  }
  return $php_ver;
}

/**
 * Checks if the PHP version is equal to the specified version or higher.
 *
 * @return bool
 */
function classes_php_version_at_least($min_ver) {
  return classes_php_version() >= classes_version_to_float($min_ver);
}


////////////////////////////////////////////////////////////////////////////////
// Functions for template rendering.

/**
 * An alternative to theme_render_template that uses a different syntax. This
 * was created so that the IDE's support for editing PHP files could be used
 * normally when editing templates.
 *
 * The function accepts an array of variable names, each with a value to be
 * substituted for the name.
 *
 * The following matching strings will be replaced for each variable name 'var':
 *   <var>
 *   '(var)'
 *   //var
 *   x_var
 *
 * @param string $tpl_path
 * @param array $vars
 * @return string
 */
function classes_render_template($tpl_path, $vars) {
  $tpl = file_get_contents($tpl_path);
  foreach ($vars as $var => $value) {
    $search = array("<$var>", "'($var)'", "//$var", "x_$var");
    $tpl = str_replace($search, $value, $tpl);
  }
  return $tpl;
}

/**
 * Check if a value is an integer, or a string that looks like one.
 *
 * @param mixed $value
 * @return bool
 */
function classes_is_int($value) {
  return is_int($value) || (is_string($value) && $value === strval((int) $value));
}


////////////////////////////////////////////////////////////////////////////////
// Functions related to MIME types.

/**
 * Gets a map of extensions to MIME types.
 *
 * This is an alternative to using the PHP Fileinfo extension, which is
 * difficult to install for PHP < 5.3.
 *
 * @param string $path_to_mime_types
 *   The path to the mime.types file.
 * @return array
 */
function classes_get_mime_types($path_to_mime_types = NULL) {
  static $mime_types;

  // If we've already loaded these, just return the array:
  if ($mime_types) {
    return $mime_types;
  }

  // Default path to mime.types is the same folder as this file:
  if (!$path_to_mime_types) {
    $pi = pathinfo(__FILE__);
    $path_to_mime_types = $pi['dirname'] . '/mime.types';
  }

  // read mime types into array:
  $fp = fopen($path_to_mime_types, 'r');
  $mime_types = array();
  while (($line = fgets($fp)) !== false) {
    $line = trim(preg_replace('/#.*/', '', $line));
    if (!$line) {
      continue;
    }
    $parts = preg_split('/\s+/', $line);
    if (count($parts) == 1) {
      continue;
    }
    $type = array_shift($parts);
    foreach($parts as $extension) {
      $mime_types[$extension] = $type;
    }
  }

  fclose($fp);
  ksort($mime_types);

  return $mime_types;
}

/**
 * Get the MIME type for a given file.
 *
 * @param string $path
 * @return string
 */
function classes_get_mime_type($path) {
  $mime_types = classes_get_mime_types();
  $pi = pathinfo($path);
  $ext = strtolower($pi['extension']);
  return $mime_types[$ext];
}


////////////////////////////////////////////////////////////////////////////////
// Reserved properties

/**
 * Get the names of all the properties in the XNodeBase class.
 *
 * @return array
 */
function classes_reserved_properties($type) {
  static $reserved;

  // First try to load from variable table:
  if (!$reserved) {
    $reserved = variable_get('classes_reserved_properties', NULL);
  }

  // If we haven't generated the reserved property names yet, do it now.
  if (TRUE) { //(!$reserved) {
    $reserved = array();

    // Tables with reserved property names:
    $tables = array(
      'node' => 'node',
      'node_revisions' => 'node',
      'users' => 'user',
    );

    // Get all the property names for fields in these tables:
    foreach ($tables as $table => $key) {
      $schema = drupal_get_schema($table);

      // Loop through the table fields, generating properties:
      foreach ($schema['fields'] as $field => $info) {

        // Rename a couple of revision fields as in node_load().
        if ($table == 'node_revisions' && in_array($field, array('timestamp', 'uid'))) {
          $field = "revision_$field";
        }

        // Generate property names from database field names:
        $property = classes_convert_case($field, CLASSES_LOWER_CASE, CLASSES_CAMEL_CASE);
        $reserved[$key][] = $property;
      }
    }

    // Add special properties. These virtual properties are available for all
    // nodes - see getCreator(), getLink() and getPath() in the XNodeBase class.
    $special_properties = array('creator', 'link', 'path');
    $reserved['node'] = array_merge($reserved['node'], $special_properties);

    // Store in the variable table:
    variable_set('classes_reserved_properties', $reserved);
  }

  // If the type is for user profiles, then include the user properties:
  if (classes_is_profile_type($type)) {
    $result = array_merge($reserved['node'], $reserved['user']);
  }
  else {
    $result = $reserved['node'];
  }

  // These properties match get* methods in XEntityBase and XNodeBase.
  $entity_properties = array('entity', 'cache', 'fieldInfo', 'properties',
    'property', 'propertyByField', 'propertyInfo', 'all', 'nids', 'options');
  $result = array_merge($result, $entity_properties);

  return $result;
}


////////////////////////////////////////////////////////////////////////////////
// Error handling functions

/**
 * Record/communicate a classes error.
 *
 * @param string $msg
 */
function classes_error($msg) {
  $backtrace = debug_backtrace();
  $msg .= " in <strong>{$backtrace[2]['file']}</strong> on line <strong>{$backtrace[2]['line']}</strong>";

  // Pass the error to Drupal's error handler:
  trigger_error($msg, E_USER_ERROR);

  // Log it:
  watchdog("Classes", $msg);

  // If display_errors is on, tell the developer:
  if (ini_get('display_errors')) {
    echo "<p><strong>Classes error</strong>: $msg</p>";
  }
}

/**
 * Report an attempt to access an unknown property.
 *
 * @param string $get_set
 *   Must be 'get' or 'set'.
 * @param string $property
 *   The invalid property name.
 * @param mixed $class
 *   The class name or object.
 */
function classes_error_property($get_set, $property, $class) {

  // If an object was passed for the $class parameter, get its class:
  if (is_object($class)) {
    $class = get_class($class);
  }

  // Create the error message:
  $msg = t("Attempt to !get_set unknown virtual property %property in an object of class %class",
    array(
      '!get_set' => ($get_set == 'get' ? t("get") : t("set")),
      '%property' => $property,
      '%class' => $class,
    )
  );

  classes_error($msg);
}

/**
 * Report an attempt to access an unknown method.
 *
 * @param string $method
 *   The invalid method name.
 * @param mixed $class
 *   The class name or object.
 */
function classes_error_method($method, $class) {

  // If an object was passed for the $class parameter, get its class:
  if (is_object($class)) {
    $class = get_class($class);
  }

  // Create the error message:
  $msg = t("Attempt to call unknown method %method on an object of class %class",
    array(
      '%method' => $method,
      '%class' => $class,
    )
  );

  classes_error($msg);
}
