<?php

/**
 * Implements hook_menu().
 */
function moonmars_update_menu() {
  $items = array();
  $items['update/subscriber-relationships'] = array(
    'page callback'    => 'moonmars_update_subscriber_relationships',
    'access arguments' => array('administer relation types'),
    'type'             => MENU_CALLBACK,
  );
  $items['named-colors'] = array(
    'page callback'    => 'moonmars_update_named_colors',
    'access callback'  => TRUE,
    'type'             => MENU_CALLBACK,
  );
//  $items['update/news-items'] = array(
//    'page callback'    => 'moonmars_update_news_items',
//    'access callback'  => TRUE,
//    'type'             => MENU_CALLBACK,
//  );
//  $items['update/channel-item-relation-changed-times'] = array(
//    'page callback'    => 'moonmars_update_channel_item_relation_changed_times',
//    'access callback'  => TRUE,
//    'type'             => MENU_CALLBACK,
//  );
  $items['update/%'] = array(
    'page callback'   => 'moonmars_update_marshall',
    'page arguments'  => array(1),
    'access callback' => TRUE,
    'type'            => MENU_CALLBACK,
  );
  return $items;
}

/**
 * General purpose function for marshalling calls to update functions.
 * Saves me having to create an entry in hook_menu() every time.
 *
 * @param string $callback
 * @return string
 */
function moonmars_update_marshall($callback) {
  $fn = 'moonmars_update_' . str_replace('-', '_', $callback);
  if (function_exists($fn)) {
    return $fn();
  }
  drupal_set_message("Invalid callback $callback", 'error');
  return '';
}

function moonmars_update_subscriber_relationships() {
  // Convert all has_follower relationships to has_subscriber:
  $rels = Relation::searchBinary('has_follower');
  foreach ($rels as $rel) {
    $member   = Member::create($rel->endpointEntityId(0));
    $follower = Member::create($rel->endpointEntityId(1));

    // Create the has_subscriber relationship:
    Relation::updateBinary('has_subscriber', 'node', $member->channel()->nid(), 'user', $follower->uid());
  }

  // Delete the has_follower relationship:
  Relation::deleteBinary('has_follower');
  Relation::deleteBinary('follows');

  // Convert all has_member relationships to has_subscriber:
  $rels = Relation::searchBinary('has_member');
  foreach ($rels as $rel) {
    $group    = Group::create($rel->endpointEntityId(0));
    $follower = Member::create($rel->endpointEntityId(1));

    // Create the has_subscriber relationship:
    Relation::updateBinary('has_subscriber', 'node', $group->channel()->nid(), 'user', $follower->uid());
  }

  // Subscribe everyone to the News channel:
  $rs = db_select('users', 'u')
    ->fields('u', array('uid'))
    ->condition('status', 1)
    ->execute();
  foreach ($rs as $rec) {
    $member = Member::create($rec->uid);

    // Create the has_subscriber relationship:
    Relation::updateBinary('has_subscriber', 'node', MOONMARS_NEWS_CHANNEL_NID, 'user', $member->uid());
  }

  // Default email_notifications to TRUE in every subscription relationship.
  $rels = Relation::searchBinary('has_subscriber', 'node', NULL, 'user', NULL);
  foreach ($rels as $rel) {
    $rel->field('field_email_notification', LANGUAGE_NONE, 0, 'value', 1);
    $rel->save();
  }

  // Delete all 'has_item' relationships where copied = 1
  $rels = Relation::searchBinary('has_item', 'node', NULL, 'node', NULL);
  foreach ($rels as $rel) {
    $copied = $rel->field('field_copied');
    if ($copied) {
      echo 'deleting ' . $rel->rid() . '<br>';
      $rel->delete();
    }
  }
}

/**
 * Sort the color names.
 */
function moonmars_update_named_colors() {
  $colors = StarColor::colorNames();
  $colors2 = array();
  foreach ($colors as $name => $hex) {
    $colors2[strtolower($name)] = strtoupper($hex);
  }
  ksort($colors2);
  dbg($colors2);
}

/**
 * Check the changed timestamps for news items.
 */
function moonmars_update_news_items() {
  // Look for relationship records:
  $q = db_select('view_channel_has_item', 'vci')
    ->fields('vci', array('item_nid', 'created'))
    ->condition('channel_nid', MOONMARS_NEWS_CHANNEL_NID)
    ->condition('item_status', 1)
    ->orderBy('created', 'DESC');

//    dpm_query($q);

  // Get the items:
  $rs = $q->execute();
  $html = "<pre>";

  foreach ($rs as $rec) {
    $item = Item::create($rec->item_nid);
    $html .= "<h1>Item " . $item->nid() . "</h1>\n";

    $relation_changed = new StarDateTime($rec->created);
    $latest = $relation_changed;
    $html .= "Relation changed time: $relation_changed\n";

    $item_changed = $item->changed();
    if ($item_changed > $latest) {
      $latest = $item_changed;
    }
    $html .= "Item changed time: $item_changed\n";

    $comments = $item->comments();
    foreach ($comments as $comment) {
      $comment_changed = $comment->changed();
      if ($comment_changed > $latest) {
        $latest = $comment_changed;
      }
      $html .= "Comment changed time: $comment_changed\n";
    }

    $html .= "<span style='color: red;'>Latest changed time: $latest</span>\n";
    $html .= ($latest == $relation_changed ? "OK" : "NOT OK") . "\n";
    $html .= "<hr>";
  }
  $html .= "</pre>";
  return $html;
}

/**
 * Update the channel-item relation changed times to the correct times.
 */
function moonmars_update_channel_item_relation_changed_times() {
  // Look for relationship records:
  $q = db_select('view_channel_has_item', 'vci')
    ->fields('vci', array('rid', 'item_nid', 'created'))
    ->condition('channel_nid', MOONMARS_NEWS_CHANNEL_NID)
//    ->range(0, 5)
//    ->orderBy('created', 'DESC');
    ->orderBy('item_created', 'DESC');

//    dpm_query($q);

  // Get the items:
  $rs = $q->execute();
  $html = "<pre>";

  foreach ($rs as $rec) {
    $item = Item::create($rec->item_nid);
    $html .= "<h1>Relation " . $rec->rid . "</h1>\n";

    $relation_changed = new StarDateTime($rec->created);
    $latest = $relation_changed;
    $html .= "Relation changed time: $relation_changed\n";

    $item_created = $item->created();
    $item_changed = $item->changed();
    if ($item_changed > $latest) {
      $latest = $item_changed;
    }
    $html .= "<b>" . $item->title() . "</b>\n";
    $html .= "Item created time: <span style='color:blue;'>$item_created</span>\n";
    $html .= "Item changed time: $item_changed\n";

    $comments = $item->comments();
    foreach ($comments as $comment) {
      $comment_changed = $comment->changed();
      if ($comment_changed > $latest) {
        $latest = $comment_changed;
      }
      $html .= "Comment changed time: $comment_changed\n";
    }

    $html .= "<span style='color: red;'>Latest changed time: $latest</span>\n";
    $html .= ($latest == $relation_changed ? "OK" : "NOT OK") . "\n";

    if ($latest != $relation_changed) {
      // Update the relation:
      $html .= "<b>Updating relation $rec->rid changed time to $latest</b>\n";

      $q2 = db_update('relation')
        ->fields(array('created' => $latest->timestamp()))
        ->condition('rid', $rec->rid);
      $html .= dbg_sql($q2) . "\n";
//      $q2->execute();
    }

    $html .= "<hr>";
  }
  $html .= "</pre>";
  return $html;
}

/**
 * Fix group references in item and comment text.
 */
function moonmars_update_fix_group_mentions() {
  // Update item text:
  $q = db_select('node', 'n')
    ->fields('n', array('nid'));
  $q->join('field_data_field_item_text', 'ft', "n.nid = ft.entity_id");
  $q->condition('field_item_text_value', '%[Group: %', 'LIKE');
  $rs = $q->execute();
  foreach ($rs as $rec) {
    $item = Item::create($rec->nid);
    $text = $item->text();
    dbg($text);

    $n = preg_match_all("/\[Group: ([^\]]+)\]/", $text, $matches);
    dbg($matches);

    $text = preg_replace("/\[Group: ([^\]]+)\]/", "[$1]", $text);
    dbg($text);

    $item->text($text);
    $item->save();

  }

  // Now comments:
  $q = db_select('comment', 'c')
    ->fields('c', array('cid'));
  $q->join('field_data_comment_body', 'fcb', "c.cid = fcb.entity_id");
  $q->condition('comment_body_value', '%[Group: %', 'LIKE');
  $rs = $q->execute();
  foreach ($rs as $rec) {
    $item_comment = ItemComment::create($rec->cid);
    $text = $item_comment->text();
    dbg($text);

    $n = preg_match_all("/\[Group: ([^\]]+)\]/", $text, $matches);
    dbg($matches);

    $text = preg_replace("/\[Group: ([^\]]+)\]/", "[$1]", $text);
    dbg($text);

    $item_comment->text($text);
    $item_comment->save();
  }

}
