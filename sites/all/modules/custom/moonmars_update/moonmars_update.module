<?php

use \AstroMultimedia\MoonMars\DateTime;
use \AstroMultimedia\MoonMars\Member;
use \AstroMultimedia\MoonMars\Group;
use \AstroMultimedia\MoonMars\Item;
use \AstroMultimedia\MoonMars\ItemComment;

/**
 * Implements hook_menu().
 */
function moonmars_update_menu() {
  $items = [];
  $items['update/%'] = [
    'page callback'   => 'moonmars_update_marshall',
    'page arguments'  => [1],
    'access callback' => TRUE,
    'type'            => MENU_CALLBACK,
  ];
  return $items;
}

/**
 * General purpose function for marshalling calls to update functions.
 * Saves me having to create an entry in hook_menu() every time.
 *
 * @param string $callback
 * @return string
 */
function moonmars_update_marshall($callback) {
  $fn = 'moonmars_update_' . str_replace('-', '_', $callback);
  if (function_exists($fn)) {
    return $fn();
  }
  drupal_set_message("Invalid callback $callback", 'error');
  return '';
}

/**
 * Update subscriber relationships.
 */
//function moonmars_update_subscriber_relationships() {
//  // Convert all has_follower relationships to has_subscriber:
//  $rels = Relation::searchBinary('has_follower');
//  foreach ($rels as $rel) {
//    $member   = Member::create($rel->endpointEntityId(0));
//    $follower = Member::create($rel->endpointEntityId(1));
//
//    // Create the has_subscriber relationship:
//    Relation::updateBinary('has_subscriber', 'node', $member->channel()->nid(), 'user', $follower->uid());
//  }
//
//  // Delete the has_follower relationship:
//  Relation::deleteBinary('has_follower');
//  Relation::deleteBinary('follows');
//
//  // Convert all has_member relationships to has_subscriber:
//  $rels = Relation::searchBinary('has_member');
//  foreach ($rels as $rel) {
//    $group    = Group::create($rel->endpointEntityId(0));
//    $follower = Member::create($rel->endpointEntityId(1));
//
//    // Create the has_subscriber relationship:
//    Relation::updateBinary('has_subscriber', 'node', $group->channel()->nid(), 'user', $follower->uid());
//  }
//
//  // Subscribe everyone to the News channel:
//  $rs = db_select('users', 'u')
//    ->fields('u', array('uid'))
//    ->condition('status', 1)
//    ->execute();
//  foreach ($rs as $rec) {
//    $member = Member::create($rec->uid);
//
//    // Create the has_subscriber relationship:
//    Relation::updateBinary('has_subscriber', 'node', MOONMARS_NEWS_CHANNEL_NID, 'user', $member->uid());
//  }
//
//  // Default email_notifications to TRUE in every subscription relationship.
//  $rels = Relation::searchBinary('has_subscriber', 'node', NULL, 'user', NULL);
//  foreach ($rels as $rel) {
//    $rel->field('field_email_notification', LANGUAGE_NONE, 0, 'value', 1);
//    $rel->save();
//  }
//
//  // Delete all 'has_item' relationships where copied = 1
//  $rels = Relation::searchBinary('has_item', 'node', NULL, 'node', NULL);
//  foreach ($rels as $rel) {
//    $copied = $rel->field('field_copied');
//    if ($copied) {
//      echo 'deleting ' . $rel->rid() . '<br>';
//      $rel->delete();
//    }
//  }
//
//}

/**
 * Sort the color names.
 */
function moonmars_update_named_colors() {
  $colors = Color::colorNames();
  $colors2 = [];
  foreach ($colors as $name => $hex) {
    $colors2[strtolower($name)] = strtoupper($hex);
  }
  ksort($colors2);
  dbg($colors2);
}

/**
 * Fix URL aliases.
 */
function moonmars_update_fix_aliases() {
  require_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'pathauto') . '/pathauto.inc';

  // Members:
  $q = db_select('users', 'u')
    ->fields('u', ['uid'])
    ->condition('uid', 0, '>');
  $rs = $q->execute();
  foreach ($rs as $rec) {
    $member = Member::create($rec->uid);
    $member->resetAlias();
    drupal_set_message("Updated member alias to <em>" . $member->alias() . "</em>");
  }

  // Groups:
  $q = db_select('node', 'n')
    ->fields('n', ['nid'])
    ->condition('type', 'group')
    ->orderBy('nid');
  $rs = $q->execute();
  foreach ($rs as $rec) {
    $group = Group::create($rec->nid);
    $group->resetAlias();
    drupal_set_message("Updated group alias to <em>" . $group->alias() . "</em>");
  }

  // Channels:
  $q = db_select('node', 'n')
    ->fields('n', ['nid'])
    ->condition('type', 'channel')
    ->orderBy('nid');
  $rs = $q->execute();
  foreach ($rs as $rec) {
    $channel = Channel::create($rec->nid);
    if ($channel->resetAlias()) {
      drupal_set_message("Updated channel alias to <em>" . $channel->alias() . "</em>");
    }
    else {
      drupal_set_message("Could not updated channel alias for <em>" . $channel->alias() . "</em>", 'warning');
    }
  }

  // Items:
  $q = db_select('node', 'n')
    ->fields('n', ['nid'])
    ->condition('type', 'item')
    ->orderBy('nid');
  $rs = $q->execute();
  foreach ($rs as $rec) {
    $item = Item::create($rec->nid);
    $alias = pathauto_create_alias('node', 'return', "node/$rec->nid", ['node' => $item->node()], 'item');
    $item->alias($alias);
    drupal_set_message("Updated item alias to <em>" . $item->alias() . "</em>");
  }

  return '';
}

/**
 * Delete channels with no parents.
 */
function moonmars_update_clean_up_channels() {
  $q = db_select('node', 'n')
    ->fields('n', ['nid'])
    ->condition('type', 'channel');
  $rs = $q->execute();
  foreach ($rs as $rec) {
    $channel = Channel::create($rec->nid);
    $parent_entity = $channel->parentEntity();
    if (!$parent_entity) {
      dpm("Channel " . $channel->nid() . " title: " . $channel->title() . " has no parent");

      $items = $channel->items();
      dpm("It contains " . count($items) . " items");

      if (count($items) == 0) {
        dpm("Deleting channel");
        $channel->delete();
      }

    }
  }
  return '';
}

/**
 * Convert all has_subscriber relationships to has_member and follows relationships.
 */
function moonmars_update_remove_subscriber_relationships() {
  // Convert all has_subscriber relationships to has_member and follows relationships:
  $rels = Relation::searchBinary('has_subscriber');

  foreach ($rels as $rel) {
    // Get the endpoints as objects:
    $channel = $rel->endpoint(0);
    $member = $rel->endpoint(1);

    if ($channel) {
      dbg("Channel " . $channel->title() . " has subscriber " . $member->name());

      $parent_entity = $channel->parentEntity();

      if ($parent_entity instanceof Member) {
        // Follows:
        dbg("Creating/updating relationship: Member " . $member->name() . " follows " . $parent_entity->name());
        Relation::updateBinary('follows', $member, $parent_entity);
      }
      elseif ($parent_entity instanceof Group) {
        // Member of a group:
        dbg("Creating/updating relationship: Group " . $parent_entity->title() . " has member " . $member->name());
        Relation::updateBinary('has_member', $parent_entity, $member);
      }
    }
  }

  // Delete all the has_subscriber relationships:
  Relation::deleteBinary('has_subscriber');
}

/**
 * Check the changed timestamps for news items.
 */
function moonmars_update_news_items() {
  // Look for relationship records:
  $q = db_select('view_channel_has_item', 'vci')
    ->fields('vci', ['item_nid', 'created'])
    ->condition('channel_nid', MOONMARS_NEWS_CHANNEL_NID)
    ->condition('item_status', 1)
    ->orderBy('created', 'DESC');

//    dpm_query($q);

  // Get the items:
  $rs = $q->execute();
  $html = "<pre>";

  foreach ($rs as $rec) {
    $item = Item::create($rec->item_nid);
    $html .= "<h1>Item " . $item->nid() . "</h1>\n";

    $relation_changed = new DateTime($rec->created);
    $latest = $relation_changed;
    $html .= "Relation changed time: $relation_changed\n";

    $item_changed = $item->changed();
    if ($item_changed > $latest) {
      $latest = $item_changed;
    }
    $html .= "Item changed time: $item_changed\n";

    $comments = $item->comments();
    foreach ($comments as $comment) {
      $comment_changed = $comment->changed();
      if ($comment_changed > $latest) {
        $latest = $comment_changed;
      }
      $html .= "Comment changed time: $comment_changed\n";
    }

    $html .= "<span style='color: red;'>Latest changed time: $latest</span>\n";
    $html .= ($latest == $relation_changed ? "OK" : "NOT OK") . "\n";
    $html .= "<hr>";
  }
  $html .= "</pre>";
  return $html;
}

/**
 * Update the channel-item relation changed times to the correct times.
 */
function moonmars_update_channel_item_relation_changed_times() {
  // Look for relationship records:
  $q = db_select('view_channel_has_item', 'vci')
    ->fields('vci', ['rid', 'item_nid', 'created'])
    ->condition('channel_nid', MOONMARS_NEWS_CHANNEL_NID)
//    ->range(0, 5)
//    ->orderBy('created', 'DESC');
    ->orderBy('item_created', 'DESC');

//    dpm_query($q);

  // Get the items:
  $rs = $q->execute();
  $html = "<pre>";

  foreach ($rs as $rec) {
    $item = Item::create($rec->item_nid);
    $html .= "<h1>Relation " . $rec->rid . "</h1>\n";

    $relation_changed = new DateTime($rec->created);
    $latest = $relation_changed;
    $html .= "Relation changed time: $relation_changed\n";

    $item_created = $item->created();
    $item_changed = $item->changed();
    if ($item_changed > $latest) {
      $latest = $item_changed;
    }
    $html .= "<b>" . $item->title() . "</b>\n";
    $html .= "Item created time: <span style='color:blue;'>$item_created</span>\n";
    $html .= "Item changed time: $item_changed\n";

    $comments = $item->comments();
    foreach ($comments as $comment) {
      $comment_changed = $comment->changed();
      if ($comment_changed > $latest) {
        $latest = $comment_changed;
      }
      $html .= "Comment changed time: $comment_changed\n";
    }

    $html .= "<span style='color: red;'>Latest changed time: $latest</span>\n";
    $html .= ($latest == $relation_changed ? "OK" : "NOT OK") . "\n";

    if ($latest != $relation_changed) {
      // Update the relation:
      $html .= "<b>Updating relation $rec->rid changed time to $latest</b>\n";

      $q2 = db_update('relation')
        ->fields(['created' => $latest->timestamp()])
        ->condition('rid', $rec->rid);
      $html .= dbg_sql($q2) . "\n";
//      $q2->execute();
    }

    $html .= "<hr>";
  }
  $html .= "</pre>";
  return $html;
}

///**
// * Fix group references in item and comment text.
// */
//function moonmars_update_fix_group_mentions() {
//  // Update item text:
//  $q = db_select('node', 'n')
//    ->fields('n', ['nid']);
//  $q->join('field_data_field_item_text', 'ft', "n.nid = ft.entity_id");
//  $q->condition('field_item_text_value', '%[Group: %', 'LIKE');
//  $rs = $q->execute();
//  foreach ($rs as $rec) {
//    $item = Item::create($rec->nid);
//    $text = $item->text();
//    dbg($text);
//
//    $n = preg_match_all("/\[(Group: )?([^\]]+)\]/", $text, $matches);
//    dbg($matches);
//
//    foreach ($matches[2] as $title) {
//      $group = Group::searchByTitle($title);
//      dbg($group);
//    }
//
////    $text = preg_replace("/\[Group: ([^\]]+)\]/", "[$1]", $text);
////    dbg($text);
////
////    $item->text($text);
////    $item->save();
//
//  }
//
//  // Now comments:
//  $q = db_select('comment', 'c')
//    ->fields('c', ['cid']);
//  $q->join('field_data_comment_body', 'fcb', "c.cid = fcb.entity_id");
//  $q->condition('comment_body_value', '%[Group: %', 'LIKE');
//  $rs = $q->execute();
//  foreach ($rs as $rec) {
//    $item_comment = ItemComment::create($rec->cid);
//    $text = $item_comment->text();
//    dbg($text);
//
//    $n = preg_match_all("/\[(Group: )?([^\]]+)\]/", $text, $matches);
//    dbg($matches);
//
//    $n = preg_match_all("/\[([^\]]+)\]/", $text, $matches);
//    dbg($matches);
//
////    $text = preg_replace("/\[Group: ([^\]]+)\]/", "[$1]", $text);
////    dbg($text);
////
////    $item_comment->text($text);
////    $item_comment->save();
//  }
//}

/**
 * Set default group tags.
 */
function moonmars_update_set_default_group_tags() {
  $q = db_select('node', 'n')
    ->fields('n', ['nid'])
    ->condition('type', 'group');
  $rs = $q->execute();
  foreach ($rs as $rec) {
    $group = Group::create($rec->nid);
    $tag = $group->tag();
    if ($tag) {
      echo "Has a tag:";
      dbg($tag);
    }
    else {
      $title = $group->title();
      dbg($title);
      $words = array_map(function($value) {
        return strtolower($value);
      }, explode(' ', $title));
      foreach ($words as $key => $word) {
        if (in_array($word, ['for', 'the', 'and', 'of', 'an', 'a'])) {
          unset($words[$key]);
        }
      }
      echo "New tag:";
      $tag = implode('-', $words);
      dbg($tag);
      $group->tag($tag);
      $group->save();
    }
    echo "<hr>";
  }
}

/**
 * Delete any relations with invalid endpoints.
 */
function moonmars_update_clean_up_relations() {
  $q = db_select('relation', 'r')
    ->fields('r', ['rid']);
  $rs = $q->execute();
  foreach ($rs as $rec) {
    $delete = FALSE;
    $rel = relation_load($rec->rid);
//    dbg($rel->endpoints);
    if (!$rel->endpoints || !$rel->endpoints[LANGUAGE_NONE]) {
      dbg("No endpoints, delete relation $rec->rid");
      $delete = TRUE;
    }
    elseif (count($rel->endpoints[LANGUAGE_NONE]) == 1) {
      dbg("Only one endpoint, delete relation $rec->rid");
      $delete = TRUE;
    }
    else {
      foreach ($rel->endpoints[LANGUAGE_NONE] as $endpoint) {
        $entity = entity_load_single($endpoint['entity_type'], $endpoint['entity_id']);
        if (!$entity) {
          dbg("Entity {$endpoint['entity_type']}:{$endpoint['entity_id']} not found, delete relation $rec->rid");
          $delete = TRUE;
        }
      }
    }
    if ($delete) {
      relation_delete($rec->rid);
    }
  }
}
